// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GLTF_GLTF_2_0_H_
#define FLATBUFFERS_GENERATED_GLTF_GLTF_2_0_H_

#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/flexbuffers.h"

namespace glTF_2_0
{

	struct AccessorSparseIndices;
	struct AccessorSparseIndicesT;

	struct AccessorSparseValues;
	struct AccessorSparseValuesT;

	struct AccessorSparse;
	struct AccessorSparseT;

	struct Accessor;
	struct AccessorT;

	struct Asset;
	struct AssetT;

	struct AnimationChannelTarget;
	struct AnimationChannelTargetT;

	struct AnimationChannel;
	struct AnimationChannelT;

	struct AnimationSampler;
	struct AnimationSamplerT;

	struct Animation;
	struct AnimationT;

	struct Buffer;
	struct BufferT;

	struct BufferView;
	struct BufferViewT;

	struct CameraOrthographic;
	struct CameraOrthographicT;

	struct CameraPerspective;
	struct CameraPerspectiveT;

	struct Camera;
	struct CameraT;

	struct Image;
	struct ImageT;

	struct TextureInfo;
	struct TextureInfoT;

	struct MaterialNormalTextureInfo;
	struct MaterialNormalTextureInfoT;

	struct MaterialOcclusionTextureInfo;
	struct MaterialOcclusionTextureInfoT;

	struct MaterialPbrMetallicRoughness;
	struct MaterialPbrMetallicRoughnessT;

	struct Material;
	struct MaterialT;

	struct MeshPrimitiveAttribute;
	struct MeshPrimitiveAttributeT;

	struct MeshPrimitive;
	struct MeshPrimitiveT;

	struct Mesh;
	struct MeshT;

	struct Node;
	struct NodeT;

	struct Scene;
	struct SceneT;

	struct Sampler;
	struct SamplerT;

	struct Texture;
	struct TextureT;

	struct Skin;
	struct SkinT;

	struct Root;
	struct RootT;

	///----------------------------------------------------------------------------
	/// The datatype of components in the attribute.
	/// gltf_detailedDescription: The datatype of components in the attribute.  All valid values correspond to WebGL
	/// enums.  The corresponding typed arrays are `Int8Array`, `Uint8Array`, `Int16Array`, `Uint16Array`,
	/// `Uint32Array`, and `Float32Array`, respectively.  5125 (UNSIGNED_INT) is only allowed when the accessor contains
	/// indices, i.e., the accessor is only referenced by `primitive.indices`. gltf_webgl: `vertexAttribPointer()` type
	/// parameter
	enum class ComponentType : int32_t
	{
		BYTE		   = 5120,
		UNSIGNED_BYTE  = 5121,
		SHORT		   = 5122,
		UNSIGNED_SHORT = 5123,
		UNSIGNED_INT   = 5125,
		FLOAT		   = 5126,
		MIN			   = BYTE,
		MAX			   = FLOAT
	};

	inline ComponentType (&EnumValuesComponentType())[6]
	{
		static ComponentType values[] = {ComponentType::BYTE,
										 ComponentType::UNSIGNED_BYTE,
										 ComponentType::SHORT,
										 ComponentType::UNSIGNED_SHORT,
										 ComponentType::UNSIGNED_INT,
										 ComponentType::FLOAT};
		return values;
	}

	inline const char** EnumNamesComponentType()
	{
		static const char* names[] = {"BYTE", "UNSIGNED_BYTE", "SHORT", "UNSIGNED_SHORT", "", "UNSIGNED_INT", "FLOAT", nullptr};
		return names;
	}

	inline const char* EnumNameComponentType(ComponentType e)
	{
		const size_t index = static_cast<int>(e) - static_cast<int>(ComponentType::BYTE);
		return EnumNamesComponentType()[index];
	}

	/// "description": "Specifies if the attribute is a scalar, vector, or matrix."
	enum class AccessorType : int16_t
	{
		SCALAR  = 0,
		VEC2	= 1,
		VEC3	= 2,
		VEC4	= 3,
		MAT2	= 4,
		MAT3	= 5,
		MAT4	= 6,
		__UNSET = 7,
		MIN		= SCALAR,
		MAX		= __UNSET
	};

	inline AccessorType (&EnumValuesAccessorType())[8]
	{
		static AccessorType values[] = {AccessorType::SCALAR,
										AccessorType::VEC2,
										AccessorType::VEC3,
										AccessorType::VEC4,
										AccessorType::MAT2,
										AccessorType::MAT3,
										AccessorType::MAT4,
										AccessorType::__UNSET};
		return values;
	}

	inline const char** EnumNamesAccessorType()
	{
		static const char* names[] = {"SCALAR", "VEC2", "VEC3", "VEC4", "MAT2", "MAT3", "MAT4", "__UNSET", nullptr};
		return names;
	}

	inline const char* EnumNameAccessorType(AccessorType e)
	{
		const size_t index = static_cast<int>(e);
		return EnumNamesAccessorType()[index];
	}

	///-- asset.schema.json --/
	///----------------------------------------------------------------------------
	///-- animation.channel.target.schema.json
	/// "description": "The name of the node's TRS property to modify, or the \"weights\" of the Morph Targets it
	/// instantiates."
	enum class AnimationChannelTargetPath : int16_t
	{
		translation = 0,
		rotation	= 1,
		scale		= 2,
		weights		= 3,
		MIN			= translation,
		MAX			= weights
	};

	inline AnimationChannelTargetPath (&EnumValuesAnimationChannelTargetPath())[4]
	{
		static AnimationChannelTargetPath values[] = {AnimationChannelTargetPath::translation,
													  AnimationChannelTargetPath::rotation,
													  AnimationChannelTargetPath::scale,
													  AnimationChannelTargetPath::weights};
		return values;
	}

	inline const char** EnumNamesAnimationChannelTargetPath()
	{
		static const char* names[] = {"translation", "rotation", "scale", "weights", nullptr};
		return names;
	}

	inline const char* EnumNameAnimationChannelTargetPath(AnimationChannelTargetPath e)
	{
		const size_t index = static_cast<int>(e);
		return EnumNamesAnimationChannelTargetPath()[index];
	}

	///-- animation.channel.schema.json --/
	///-- animation.sampler.schema.json
	/// "description": "Interpolation algorithm."
	/// "gltf_detailedDescription": "Interpolation algorithm."
	enum class AnimationSamplerInterpolationAlgorithm : int16_t
	{
		/// "description": "The animated values are linearly interpolated between keyframes. When targeting a rotation,
		/// spherical linear interpolation (slerp) should be used to interpolate quaternions. The number output of
		/// elements must equal the number of input elements."
		LINEAR = 0	/// "description": "The animated values remain constant to the output of the first keyframe, until
					  /// the next keyframe. The number of output elements must equal the number of input elements."
		,
		STEP = 1	/// "description": "The animation's interpolation is computed using a uniform Catmull-Rom spline.
					/// The number of output elements must equal two more than the number of input elements. The first
					/// and last output elements represent the start and end tangents of the spline. There must be at
					/// least four keyframes when using this interpolation."
		,
		CATMULLROMSPLINE = 2	/// "description": "The animation's interpolation is computed using a cubic spline with
								/// specified tangents. The number of output elements must equal three times the number
								/// of input elements. For each input element, the output stores three elements, an
								/// in-tangent, a spline vertex, and an out-tangent. There must be at least two
								/// keyframes when using this interpolation."
		,
		CUBICSPLINE = 3,
		MIN			= LINEAR,
		MAX			= CUBICSPLINE
	};

	inline AnimationSamplerInterpolationAlgorithm (&EnumValuesAnimationSamplerInterpolationAlgorithm())[4]
	{
		static AnimationSamplerInterpolationAlgorithm values[] = {AnimationSamplerInterpolationAlgorithm::LINEAR,
																  AnimationSamplerInterpolationAlgorithm::STEP,
																  AnimationSamplerInterpolationAlgorithm::CATMULLROMSPLINE,
																  AnimationSamplerInterpolationAlgorithm::CUBICSPLINE};
		return values;
	}

	inline const char** EnumNamesAnimationSamplerInterpolationAlgorithm()
	{
		static const char* names[] = {"LINEAR", "STEP", "CATMULLROMSPLINE", "CUBICSPLINE", nullptr};
		return names;
	}

	inline const char* EnumNameAnimationSamplerInterpolationAlgorithm(AnimationSamplerInterpolationAlgorithm e)
	{
		const size_t index = static_cast<int>(e);
		return EnumNamesAnimationSamplerInterpolationAlgorithm()[index];
	}

	///-- buffer.schema.json --/
	///----------------------------------------------------------------------------
	///-- bufferView.schema.json
	/// "description": "The target that the GPU buffer should be bound to."
	/// "gltf_webgl": "`bindBuffer()`"
	enum class BufferViewTarget : int32_t
	{
		ARRAY_BUFFER		 = 34962,
		ELEMENT_ARRAY_BUFFER = 34963,
		MIN					 = ARRAY_BUFFER,
		MAX					 = ELEMENT_ARRAY_BUFFER
	};

	inline BufferViewTarget (&EnumValuesBufferViewTarget())[2]
	{
		static BufferViewTarget values[] = {BufferViewTarget::ARRAY_BUFFER, BufferViewTarget::ELEMENT_ARRAY_BUFFER};
		return values;
	}

	inline const char** EnumNamesBufferViewTarget()
	{
		static const char* names[] = {"ARRAY_BUFFER", "ELEMENT_ARRAY_BUFFER", nullptr};
		return names;
	}

	inline const char* EnumNameBufferViewTarget(BufferViewTarget e)
	{
		const size_t index = static_cast<int>(e) - static_cast<int>(BufferViewTarget::ARRAY_BUFFER);
		return EnumNamesBufferViewTarget()[index];
	}

	///-- camera.perspective.schema.json --/
	///-- camera.schema.json
	/// "description": "Specifies if the camera uses a perspective or orthographic projection."
	/// "gltf_detailedDescription": "Specifies if the camera uses a perspective or orthographic projection.  Based on
	/// this, either the camera's `perspective` or `orthographic` property will be defined."
	enum class CameraType : int16_t
	{
		perspective  = 0,
		orthographic = 1,
		MIN			 = perspective,
		MAX			 = orthographic
	};

	inline CameraType (&EnumValuesCameraType())[2]
	{
		static CameraType values[] = {CameraType::perspective, CameraType::orthographic};
		return values;
	}

	inline const char** EnumNamesCameraType()
	{
		static const char* names[] = {"perspective", "orthographic", nullptr};
		return names;
	}

	inline const char* EnumNameCameraType(CameraType e)
	{
		const size_t index = static_cast<int>(e);
		return EnumNamesCameraType()[index];
	}

	///-- material.pbrMetallicRoughness.schema.json --/
	///-- material.schema.json
	/// "description": "The alpha rendering mode of the material."
	/// "gltf_detailedDescription": "The material's alpha rendering mode enumeration specifying the interpretation of
	/// the alpha value of the main factor and texture."
	enum class MaterialAlphaMode : int16_t
	{
		/// "description": "The alpha value is ignored and the rendered output is fully opaque."
		OPAQUE = 0	/// "description": "The rendered output is either fully opaque or fully transparent depending on
					  /// the alpha value and the specified alpha cutoff value."
		,
		MASK = 1	/// "description": "The alpha value is used to composite the source and destination areas. The
					/// rendered output is combined with the background using the normal painting operation (i.e. the
					/// Porter and Duff over operator)."
		,
		BLEND = 2,
		MIN   = OPAQUE,
		MAX   = BLEND
	};

	inline MaterialAlphaMode (&EnumValuesMaterialAlphaMode())[3]
	{
		static MaterialAlphaMode values[] = {MaterialAlphaMode::OPAQUE, MaterialAlphaMode::MASK, MaterialAlphaMode::BLEND};
		return values;
	}

	inline const char** EnumNamesMaterialAlphaMode()
	{
		static const char* names[] = {"OPAQUE", "MASK", "BLEND", nullptr};
		return names;
	}

	inline const char* EnumNameMaterialAlphaMode(MaterialAlphaMode e)
	{
		const size_t index = static_cast<int>(e);
		return EnumNamesMaterialAlphaMode()[index];
	}

	///-- material.schema.json --/
	///----------------------------------------------------------------------------
	///-- mesh.primitive.schema.json
	enum class MeshPrimitiveMode : uint8_t
	{
		POINTS		   = 0,
		LINES		   = 1,
		LINE_LOOP	  = 2,
		LINE_STRIP	 = 3,
		TRIANGLES	  = 4,
		TRIANGLE_STRIP = 5,
		TRIANGLE_FAN   = 6,
		MIN			   = POINTS,
		MAX			   = TRIANGLE_FAN
	};

	inline MeshPrimitiveMode (&EnumValuesMeshPrimitiveMode())[7]
	{
		static MeshPrimitiveMode values[] = {MeshPrimitiveMode::POINTS,
											 MeshPrimitiveMode::LINES,
											 MeshPrimitiveMode::LINE_LOOP,
											 MeshPrimitiveMode::LINE_STRIP,
											 MeshPrimitiveMode::TRIANGLES,
											 MeshPrimitiveMode::TRIANGLE_STRIP,
											 MeshPrimitiveMode::TRIANGLE_FAN};
		return values;
	}

	inline const char** EnumNamesMeshPrimitiveMode()
	{
		static const char* names[]
		  = {"POINTS", "LINES", "LINE_LOOP", "LINE_STRIP", "TRIANGLES", "TRIANGLE_STRIP", "TRIANGLE_FAN", nullptr};
		return names;
	}

	inline const char* EnumNameMeshPrimitiveMode(MeshPrimitiveMode e)
	{
		const size_t index = static_cast<int>(e);
		return EnumNamesMeshPrimitiveMode()[index];
	}

	///-- scene.schema.json --/
	///----------------------------------------------------------------------------
	///-- sampler.schema.
	/// "gltf_detailedDescription": "All valid values correspond to WebGL enums."
	enum class SamplerFilter : int32_t
	{
		NEAREST				   = 9728,
		LINEAR				   = 9729,
		NEAREST_MIPMAP_NEAREST = 9984,
		LINEAR_MIPMAP_NEAREST  = 9985,
		NEAREST_MIPMAP_LINEAR  = 9986,
		LINEAR_MIPMAP_LINEAR   = 9987,
		MIN					   = NEAREST,
		MAX					   = LINEAR_MIPMAP_LINEAR
	};

	inline SamplerFilter (&EnumValuesSamplerFilter())[6]
	{
		static SamplerFilter values[] = {SamplerFilter::NEAREST,
										 SamplerFilter::LINEAR,
										 SamplerFilter::NEAREST_MIPMAP_NEAREST,
										 SamplerFilter::LINEAR_MIPMAP_NEAREST,
										 SamplerFilter::NEAREST_MIPMAP_LINEAR,
										 SamplerFilter::LINEAR_MIPMAP_LINEAR};
		return values;
	}

	/// "gltf_detailedDescription": "All valid values correspond to WebGL enums."
	enum class WrapMode : int32_t
	{
		REPEAT			= 10497,
		CLAMP_TO_EDGE   = 33071,
		MIRRORED_REPEAT = 33648,
		MIN				= REPEAT,
		MAX				= MIRRORED_REPEAT
	};

	inline WrapMode (&EnumValuesWrapMode())[3]
	{
		static WrapMode values[] = {WrapMode::REPEAT, WrapMode::CLAMP_TO_EDGE, WrapMode::MIRRORED_REPEAT};
		return values;
	}

	///----------------------------------------------------------------------------
	///-- glTF-binary
	/// enums for glTF-binary/GLB files
	enum class GLBConstant : uint32_t
	{
		/// version indicates the version of the Binary glTF container format. This specification defines version 2.
		version = 2	/// chunkType equals 0x004E4942	, ASCII string 'BIN'
		,
		binary = 5130562	/// magic equals 0x46546C67. It is ASCII string 'glTF', and can be used to identify data as
							/// Binary glTF.
		,
		magic = 1179937895	/// chunkType equals 0x4E4F534A, ASCII string 'JSON'
		,
		json = 1313821514,
		MIN  = version,
		MAX  = json
	};

	inline GLBConstant (&EnumValuesGLBConstant())[4]
	{
		static GLBConstant values[] = {GLBConstant::version, GLBConstant::binary, GLBConstant::magic, GLBConstant::json};
		return values;
	}

	struct AccessorSparseIndicesT : public flatbuffers::NativeTable
	{
		typedef AccessorSparseIndices			 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.AccessorSparseIndicesT";
		}
		int32_t				 bufferView;
		int32_t				 byeOffset;
		int32_t				 componentType;
		std::vector<uint8_t> extensions;
		std::vector<uint8_t> extras;
		AccessorSparseIndicesT() : bufferView(-1), byeOffset(0), componentType(-1)
		{
		}
	};

	///-- accessor.sparse.indices.schema.json
	struct AccessorSparseIndices FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef AccessorSparseIndicesT			 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.AccessorSparseIndices";
		}
		enum
		{
			VT_BUFFERVIEW	= 4,
			VT_BYEOFFSET	 = 6,
			VT_COMPONENTTYPE = 8,
			VT_EXTENSIONS	= 10,
			VT_EXTRAS		 = 12
		};
		/// "description": "The index of the bufferView with sparse indices. Referenced bufferView can't have
		/// ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target."
		int32_t bufferView() const
		{
			return GetField<int32_t>(VT_BUFFERVIEW, -1);
		}
		bool mutate_bufferView(int32_t _bufferView)
		{
			return SetField<int32_t>(VT_BUFFERVIEW, _bufferView, -1);
		}
		/// "description": "The offset relative to the start of the bufferView in bytes. Must be aligned."
		int32_t byeOffset() const
		{
			return GetField<int32_t>(VT_BYEOFFSET, 0);
		}
		bool mutate_byeOffset(int32_t _byeOffset)
		{
			return SetField<int32_t>(VT_BYEOFFSET, _byeOffset, 0);
		}
		int32_t componentType() const
		{
			return GetField<int32_t>(VT_COMPONENTTYPE, -1);
		}
		bool mutate_componentType(int32_t _componentType)
		{
			return SetField<int32_t>(VT_COMPONENTTYPE, _componentType, -1);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_BUFFERVIEW)
				   && VerifyField<int32_t>(verifier, VT_BYEOFFSET) && VerifyField<int32_t>(verifier, VT_COMPONENTTYPE)
				   && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		AccessorSparseIndicesT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void UnPackTo(AccessorSparseIndicesT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<AccessorSparseIndices> Pack(flatbuffers::FlatBufferBuilder&		   _fbb,
															   const AccessorSparseIndicesT*		   _o,
															   const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct AccessorSparseIndicesBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_bufferView(int32_t bufferView)
		{
			fbb_.AddElement<int32_t>(AccessorSparseIndices::VT_BUFFERVIEW, bufferView, -1);
		}
		void add_byeOffset(int32_t byeOffset)
		{
			fbb_.AddElement<int32_t>(AccessorSparseIndices::VT_BYEOFFSET, byeOffset, 0);
		}
		void add_componentType(int32_t componentType)
		{
			fbb_.AddElement<int32_t>(AccessorSparseIndices::VT_COMPONENTTYPE, componentType, -1);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(AccessorSparseIndices::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(AccessorSparseIndices::VT_EXTRAS, extras);
		}
		AccessorSparseIndicesBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		AccessorSparseIndicesBuilder&			   operator=(const AccessorSparseIndicesBuilder&);
		flatbuffers::Offset<AccessorSparseIndices> Finish()
		{
			const auto end = fbb_.EndTable(start_, 5);
			auto	   o   = flatbuffers::Offset<AccessorSparseIndices>(end);
			return o;
		}
	};

	inline flatbuffers::Offset<AccessorSparseIndices>
	CreateAccessorSparseIndices(flatbuffers::FlatBufferBuilder&					  _fbb,
								int32_t											  bufferView	= -1,
								int32_t											  byeOffset		= 0,
								int32_t											  componentType = -1,
								flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions	= 0,
								flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras		= 0)
	{
		AccessorSparseIndicesBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_componentType(componentType);
		builder_.add_byeOffset(byeOffset);
		builder_.add_bufferView(bufferView);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<AccessorSparseIndices> CreateAccessorSparseIndicesDirect(flatbuffers::FlatBufferBuilder& _fbb,
																						int32_t bufferView	= -1,
																						int32_t byeOffset	 = 0,
																						int32_t componentType = -1,
																						const std::vector<uint8_t>* extensions = nullptr,
																						const std::vector<uint8_t>* extras = nullptr)
	{
		return glTF_2_0::CreateAccessorSparseIndices(_fbb,
													 bufferView,
													 byeOffset,
													 componentType,
													 extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
													 extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<AccessorSparseIndices> CreateAccessorSparseIndices(flatbuffers::FlatBufferBuilder& _fbb,
																		   const AccessorSparseIndicesT*   _o,
																		   const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	struct AccessorSparseValuesT : public flatbuffers::NativeTable
	{
		typedef AccessorSparseValues			 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.AccessorSparseValuesT";
		}
		int32_t				 bufferView;
		int32_t				 byteOffset;
		std::vector<uint8_t> extensions;
		std::vector<uint8_t> extras;
		AccessorSparseValuesT() : bufferView(-1), byteOffset(0)
		{
		}
	};

	///-- accessor.sparse.indices.schema.json --/
	///-- accessor.sparse.values.schema.json
	struct AccessorSparseValues FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef AccessorSparseValuesT			 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.AccessorSparseValues";
		}
		enum
		{
			VT_BUFFERVIEW = 4,
			VT_BYTEOFFSET = 6,
			VT_EXTENSIONS = 8,
			VT_EXTRAS	 = 10
		};
		/// "description": "The index of the bufferView with sparse values. Referenced bufferView can't have
		/// ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target."
		int32_t bufferView() const
		{
			return GetField<int32_t>(VT_BUFFERVIEW, -1);
		}
		bool mutate_bufferView(int32_t _bufferView)
		{
			return SetField<int32_t>(VT_BUFFERVIEW, _bufferView, -1);
		}
		/// "description": "The offset relative to the start of the bufferView in bytes. Must be aligned."
		int32_t byteOffset() const
		{
			return GetField<int32_t>(VT_BYTEOFFSET, 0);
		}
		bool mutate_byteOffset(int32_t _byteOffset)
		{
			return SetField<int32_t>(VT_BYTEOFFSET, _byteOffset, 0);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_BUFFERVIEW)
				   && VerifyField<int32_t>(verifier, VT_BYTEOFFSET) && VerifyOffset(verifier, VT_EXTENSIONS)
				   && verifier.Verify(extensions()) && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras())
				   && verifier.EndTable();
		}
		AccessorSparseValuesT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void UnPackTo(AccessorSparseValuesT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<AccessorSparseValues> Pack(flatbuffers::FlatBufferBuilder&		  _fbb,
															  const AccessorSparseValuesT*			  _o,
															  const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct AccessorSparseValuesBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_bufferView(int32_t bufferView)
		{
			fbb_.AddElement<int32_t>(AccessorSparseValues::VT_BUFFERVIEW, bufferView, -1);
		}
		void add_byteOffset(int32_t byteOffset)
		{
			fbb_.AddElement<int32_t>(AccessorSparseValues::VT_BYTEOFFSET, byteOffset, 0);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(AccessorSparseValues::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(AccessorSparseValues::VT_EXTRAS, extras);
		}
		AccessorSparseValuesBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		AccessorSparseValuesBuilder&			  operator=(const AccessorSparseValuesBuilder&);
		flatbuffers::Offset<AccessorSparseValues> Finish()
		{
			const auto end = fbb_.EndTable(start_, 4);
			auto	   o   = flatbuffers::Offset<AccessorSparseValues>(end);
			return o;
		}
	};

	inline flatbuffers::Offset<AccessorSparseValues>
	CreateAccessorSparseValues(flatbuffers::FlatBufferBuilder&					 _fbb,
							   int32_t											 bufferView = -1,
							   int32_t											 byteOffset = 0,
							   flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions = 0,
							   flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras		= 0)
	{
		AccessorSparseValuesBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_byteOffset(byteOffset);
		builder_.add_bufferView(bufferView);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<AccessorSparseValues> CreateAccessorSparseValuesDirect(flatbuffers::FlatBufferBuilder& _fbb,
																					  int32_t bufferView = -1,
																					  int32_t byteOffset = 0,
																					  const std::vector<uint8_t>* extensions = nullptr,
																					  const std::vector<uint8_t>* extras = nullptr)
	{
		return glTF_2_0::CreateAccessorSparseValues(_fbb,
													bufferView,
													byteOffset,
													extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
													extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<AccessorSparseValues> CreateAccessorSparseValues(flatbuffers::FlatBufferBuilder& _fbb,
																		 const AccessorSparseValuesT*	_o,
																		 const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	struct AccessorSparseT : public flatbuffers::NativeTable
	{
		typedef AccessorSparse					 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.AccessorSparseT";
		}
		int32_t												 count;
		std::vector<std::unique_ptr<AccessorSparseIndicesT>> indices;
		std::vector<std::unique_ptr<AccessorSparseValuesT>>  values;
		std::vector<uint8_t>								 extensions;
		std::vector<uint8_t>								 extras;
		AccessorSparseT() : count(0)
		{
		}
	};

	///-- accessor.sparse.values.schema.json --/
	///-- accessor.sparse.schema.json
	/// Accessor Sparse
	struct AccessorSparse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef AccessorSparseT					 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.AccessorSparse";
		}
		enum
		{
			VT_COUNT	  = 4,
			VT_INDICES	= 6,
			VT_VALUES	 = 8,
			VT_EXTENSIONS = 10,
			VT_EXTRAS	 = 12
		};
		/// "description": "Number of entries stored in the sparse array."
		/// "gltf_detailedDescription": "The number of attributes encoded in this sparse accessor."
		/// "minimum": 1
		int32_t count() const
		{
			return GetField<int32_t>(VT_COUNT, 0);
		}
		bool mutate_count(int32_t _count)
		{
			return SetField<int32_t>(VT_COUNT, _count, 0);
		}
		/// "description": "Index array of size `count` that points to those accessor attributes that deviate from their
		/// initialization value. Indices must strictly increase."
		const flatbuffers::Vector<flatbuffers::Offset<AccessorSparseIndices>>* indices() const
		{
			return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AccessorSparseIndices>>*>(VT_INDICES);
		}
		flatbuffers::Vector<flatbuffers::Offset<AccessorSparseIndices>>* mutable_indices()
		{
			return GetPointer<flatbuffers::Vector<flatbuffers::Offset<AccessorSparseIndices>>*>(VT_INDICES);
		}
		/// "description": "Array of size `count` times number of components, storing the displaced accessor attributes
		/// pointed by `indices`. Substituted values must have the same `componentType` and number of components as the
		/// base accessor."
		const flatbuffers::Vector<flatbuffers::Offset<AccessorSparseValues>>* values() const
		{
			return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AccessorSparseValues>>*>(VT_VALUES);
		}
		flatbuffers::Vector<flatbuffers::Offset<AccessorSparseValues>>* mutable_values()
		{
			return GetPointer<flatbuffers::Vector<flatbuffers::Offset<AccessorSparseValues>>*>(VT_VALUES);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_COUNT)
				   && VerifyOffsetRequired(verifier, VT_INDICES) && verifier.Verify(indices())
				   && verifier.VerifyVectorOfTables(indices()) && VerifyOffsetRequired(verifier, VT_VALUES)
				   && verifier.Verify(values()) && verifier.VerifyVectorOfTables(values())
				   && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		AccessorSparseT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void UnPackTo(AccessorSparseT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<AccessorSparse> Pack(flatbuffers::FlatBufferBuilder&			_fbb,
														const AccessorSparseT*					_o,
														const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct AccessorSparseBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_count(int32_t count)
		{
			fbb_.AddElement<int32_t>(AccessorSparse::VT_COUNT, count, 0);
		}
		void add_indices(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AccessorSparseIndices>>> indices)
		{
			fbb_.AddOffset(AccessorSparse::VT_INDICES, indices);
		}
		void add_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AccessorSparseValues>>> values)
		{
			fbb_.AddOffset(AccessorSparse::VT_VALUES, values);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(AccessorSparse::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(AccessorSparse::VT_EXTRAS, extras);
		}
		AccessorSparseBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		AccessorSparseBuilder&				operator=(const AccessorSparseBuilder&);
		flatbuffers::Offset<AccessorSparse> Finish()
		{
			const auto end = fbb_.EndTable(start_, 5);
			auto	   o   = flatbuffers::Offset<AccessorSparse>(end);
			fbb_.Required(o, AccessorSparse::VT_INDICES);
			fbb_.Required(o, AccessorSparse::VT_VALUES);
			return o;
		}
	};

	inline flatbuffers::Offset<AccessorSparse>
	CreateAccessorSparse(flatbuffers::FlatBufferBuilder&													  _fbb,
						 int32_t																			  count = 0,
						 flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AccessorSparseIndices>>> indices = 0,
						 flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AccessorSparseValues>>> values = 0,
						 flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions								= 0,
						 flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras									= 0)
	{
		AccessorSparseBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_values(values);
		builder_.add_indices(indices);
		builder_.add_count(count);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<AccessorSparse>
	CreateAccessorSparseDirect(flatbuffers::FlatBufferBuilder&								  _fbb,
							   int32_t														  count		 = 0,
							   const std::vector<flatbuffers::Offset<AccessorSparseIndices>>* indices	= nullptr,
							   const std::vector<flatbuffers::Offset<AccessorSparseValues>>*  values	 = nullptr,
							   const std::vector<uint8_t>*									  extensions = nullptr,
							   const std::vector<uint8_t>*									  extras	 = nullptr)
	{
		return glTF_2_0::CreateAccessorSparse(_fbb,
											  count,
											  indices ? _fbb.CreateVector<flatbuffers::Offset<AccessorSparseIndices>>(*indices) : 0,
											  values ? _fbb.CreateVector<flatbuffers::Offset<AccessorSparseValues>>(*values) : 0,
											  extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
											  extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<AccessorSparse> CreateAccessorSparse(flatbuffers::FlatBufferBuilder&		 _fbb,
															 const AccessorSparseT*					 _o,
															 const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	struct AccessorT : public flatbuffers::NativeTable
	{
		typedef Accessor						 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.AccessorT";
		}
		int32_t										  bufferView;
		int32_t										  byteOffset;
		int32_t										  componentType;
		bool										  normalized;
		int32_t										  count;
		AccessorType								  type;
		std::vector<float>							  max;
		std::vector<float>							  min;
		std::vector<std::unique_ptr<AccessorSparseT>> sparse;
		std::string									  name;
		std::vector<uint8_t>						  extensions;
		std::vector<uint8_t>						  extras;
		AccessorT()
			: bufferView(-1), byteOffset(0), componentType(-1), normalized(false), count(1), type(AccessorType::__UNSET)
		{
		}
	};

	///-- accessor.sparse.schema.json --/
	/// A typed view into a bufferView.  A bufferView contains raw binary data.  An accessor provides a typed view into
	/// a bufferView or a subset of a bufferView similar to how WebGL's `vertexAttribPointer()` defines an attribute in
	/// a buffer.
	struct Accessor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef AccessorT						 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.Accessor";
		}
		enum
		{
			VT_BUFFERVIEW	= 4,
			VT_BYTEOFFSET	= 6,
			VT_COMPONENTTYPE = 8,
			VT_NORMALIZED	= 10,
			VT_COUNT		 = 12,
			VT_TYPE			 = 14,
			VT_MAX			 = 16,
			VT_MIN			 = 18,
			VT_SPARSE		 = 20,
			VT_NAME			 = 22,
			VT_EXTENSIONS	= 24,
			VT_EXTRAS		 = 26
		};
		/// "description": "The index of the bufferView."
		/// "gltf_detailedDescription": "The index of the bufferView. When not defined, accessor must be initialized
		/// with zeros; `sparse` property or extensions could override zeros with actual values."
		int32_t bufferView() const
		{
			return GetField<int32_t>(VT_BUFFERVIEW, -1);
		}
		bool mutate_bufferView(int32_t _bufferView)
		{
			return SetField<int32_t>(VT_BUFFERVIEW, _bufferView, -1);
		}
		/// "description": "The offset relative to the start of the bufferView in bytes."
		/// "gltf_detailedDescription": "The offset relative to the start of the bufferView in bytes.  This must be a
		/// multiple of the size of the component datatype." "gltf_webgl": "`vertexAttribPointer()` offset parameter"
		int32_t byteOffset() const
		{
			return GetField<int32_t>(VT_BYTEOFFSET, 0);
		}
		bool mutate_byteOffset(int32_t _byteOffset)
		{
			return SetField<int32_t>(VT_BYTEOFFSET, _byteOffset, 0);
		}
		/// "description": "The datatype of components in the attribute."
		/// "gltf_detailedDescription": "The datatype of components in the attribute.  All valid values correspond to
		/// WebGL enums.  The corresponding typed arrays are `Int8Array`, `Uint8Array`, `Int16Array`, `Uint16Array`,
		/// `Uint32Array`, and `Float32Array`, respectively.  5125 (UNSIGNED_INT) is only allowed when the accessor
		/// contains indices, i.e., the accessor is only referenced by `primitive.indices`." "gltf_webgl":
		/// "`vertexAttribPointer()` type parameter"
		int32_t componentType() const
		{
			return GetField<int32_t>(VT_COMPONENTTYPE, -1);
		}
		bool mutate_componentType(int32_t _componentType)
		{
			return SetField<int32_t>(VT_COMPONENTTYPE, _componentType, -1);
		}
		/// "description": "Specifies whether integer data values should be normalized."
		/// "gltf_detailedDescription": "Specifies whether integer data values should be normalized (`true`) to [0, 1]
		/// (for unsigned types) or [-1, 1] (for signed types), or converted directly (`false`) when they are accessed.
		/// This property is defined only for accessors that contain vertex attributes or animation output data."
		/// "gltf_webgl": "`vertexAttribPointer()` normalized parameter"
		bool normalized() const
		{
			return GetField<uint8_t>(VT_NORMALIZED, 0) != 0;
		}
		bool mutate_normalized(bool _normalized)
		{
			return SetField<uint8_t>(VT_NORMALIZED, static_cast<uint8_t>(_normalized), 0);
		}
		/// "description": "The number of attributes referenced by this accessor."
		/// "gltf_detailedDescription": "The number of attributes referenced by this accessor, not to be confused with
		/// the number of bytes or number of components."
		int32_t count() const
		{
			return GetField<int32_t>(VT_COUNT, 1);
		}
		bool mutate_count(int32_t _count)
		{
			return SetField<int32_t>(VT_COUNT, _count, 1);
		}
		/// "description": "Specifies if the attribute is a scalar, vector, or matrix."
		AccessorType type() const
		{
			return static_cast<AccessorType>(GetField<int16_t>(VT_TYPE, 7));
		}
		bool mutate_type(AccessorType _type)
		{
			return SetField<int16_t>(VT_TYPE, static_cast<int16_t>(_type), 7);
		}
		///  "description": "Maximum value of each component in this attribute."
		/// "minItems": 1,
		/// "maxItems": 16,
		/// "gltf_detailedDescription": "Maximum value of each component in this attribute.  Array elements must be
		/// treated as having the same data type as accessor's `componentType`. Both min and max arrays have the same
		/// length.  The length is determined by the value of the type property; it can be 1, 2, 3, 4, 9,
		/// or 16.\n\n`normalized` property has no effect on array values: they always correspond to the actual values
		/// stored in the buffer. When accessor is sparse, this property must contain max values of accessor data with
		/// sparse substitution applied."
		const flatbuffers::Vector<float>* max() const
		{
			return GetPointer<const flatbuffers::Vector<float>*>(VT_MAX);
		}
		flatbuffers::Vector<float>* mutable_max()
		{
			return GetPointer<flatbuffers::Vector<float>*>(VT_MAX);
		}
		/// "description": "Minimum value of each component in this attribute."
		/// "minItems": 1,
		/// "maxItems": 16,
		/// "gltf_detailedDescription": "Minimum value of each component in this attribute.  Array elements must be
		/// treated as having the same data type as accessor's `componentType`. Both min and max arrays have the same
		/// length.  The length is determined by the value of the type property; it can be 1, 2, 3, 4, 9,
		/// or 16.\n\n`normalized` property has no effect on array values: they always correspond to the actual values
		/// stored in the buffer. When accessor is sparse, this property must contain min values of accessor data with
		/// sparse substitution applied."
		const flatbuffers::Vector<float>* min() const
		{
			return GetPointer<const flatbuffers::Vector<float>*>(VT_MIN);
		}
		flatbuffers::Vector<float>* mutable_min()
		{
			return GetPointer<flatbuffers::Vector<float>*>(VT_MIN);
		}
		/// "description": "Sparse storage of attributes that deviate from their initialization value."
		const flatbuffers::Vector<flatbuffers::Offset<AccessorSparse>>* sparse() const
		{
			return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AccessorSparse>>*>(VT_SPARSE);
		}
		flatbuffers::Vector<flatbuffers::Offset<AccessorSparse>>* mutable_sparse()
		{
			return GetPointer<flatbuffers::Vector<flatbuffers::Offset<AccessorSparse>>*>(VT_SPARSE);
		}
		///-- glTFChildOfRootProperty
		/// The user-defined name of this object.
		/// gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an
		/// accessor and a buffer could have the same name, or two accessors could even have the same name.
		const flatbuffers::String* name() const
		{
			return GetPointer<const flatbuffers::String*>(VT_NAME);
		}
		flatbuffers::String* mutable_name()
		{
			return GetPointer<flatbuffers::String*>(VT_NAME);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_BUFFERVIEW)
				   && VerifyField<int32_t>(verifier, VT_BYTEOFFSET) && VerifyField<int32_t>(verifier, VT_COMPONENTTYPE)
				   && VerifyField<uint8_t>(verifier, VT_NORMALIZED) && VerifyField<int32_t>(verifier, VT_COUNT)
				   && VerifyField<int16_t>(verifier, VT_TYPE) && VerifyOffset(verifier, VT_MAX) && verifier.Verify(max())
				   && VerifyOffset(verifier, VT_MIN) && verifier.Verify(min()) && VerifyOffset(verifier, VT_SPARSE)
				   && verifier.Verify(sparse()) && verifier.VerifyVectorOfTables(sparse()) && VerifyOffset(verifier, VT_NAME)
				   && verifier.Verify(name()) && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		AccessorT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void	   UnPackTo(AccessorT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<Accessor> Pack(flatbuffers::FlatBufferBuilder&		  _fbb,
												  const AccessorT*						  _o,
												  const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct AccessorBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_bufferView(int32_t bufferView)
		{
			fbb_.AddElement<int32_t>(Accessor::VT_BUFFERVIEW, bufferView, -1);
		}
		void add_byteOffset(int32_t byteOffset)
		{
			fbb_.AddElement<int32_t>(Accessor::VT_BYTEOFFSET, byteOffset, 0);
		}
		void add_componentType(int32_t componentType)
		{
			fbb_.AddElement<int32_t>(Accessor::VT_COMPONENTTYPE, componentType, -1);
		}
		void add_normalized(bool normalized)
		{
			fbb_.AddElement<uint8_t>(Accessor::VT_NORMALIZED, static_cast<uint8_t>(normalized), 0);
		}
		void add_count(int32_t count)
		{
			fbb_.AddElement<int32_t>(Accessor::VT_COUNT, count, 1);
		}
		void add_type(AccessorType type)
		{
			fbb_.AddElement<int16_t>(Accessor::VT_TYPE, static_cast<int16_t>(type), 7);
		}
		void add_max(flatbuffers::Offset<flatbuffers::Vector<float>> max)
		{
			fbb_.AddOffset(Accessor::VT_MAX, max);
		}
		void add_min(flatbuffers::Offset<flatbuffers::Vector<float>> min)
		{
			fbb_.AddOffset(Accessor::VT_MIN, min);
		}
		void add_sparse(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AccessorSparse>>> sparse)
		{
			fbb_.AddOffset(Accessor::VT_SPARSE, sparse);
		}
		void add_name(flatbuffers::Offset<flatbuffers::String> name)
		{
			fbb_.AddOffset(Accessor::VT_NAME, name);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(Accessor::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(Accessor::VT_EXTRAS, extras);
		}
		AccessorBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		AccessorBuilder&			  operator=(const AccessorBuilder&);
		flatbuffers::Offset<Accessor> Finish()
		{
			const auto end = fbb_.EndTable(start_, 12);
			auto	   o   = flatbuffers::Offset<Accessor>(end);
			return o;
		}
	};

	inline flatbuffers::Offset<Accessor> CreateAccessor(flatbuffers::FlatBufferBuilder& _fbb,
														int32_t							bufferView	= -1,
														int32_t							byteOffset	= 0,
														int32_t							componentType = -1,
														bool							normalized	= false,
														int32_t							count		  = 1,
														AccessorType					type = AccessorType::__UNSET,
														flatbuffers::Offset<flatbuffers::Vector<float>> max = 0,
														flatbuffers::Offset<flatbuffers::Vector<float>> min = 0,
														flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AccessorSparse>>> sparse
														= 0,
														flatbuffers::Offset<flatbuffers::String>		  name = 0,
														flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions = 0,
														flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras = 0)
	{
		AccessorBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_name(name);
		builder_.add_sparse(sparse);
		builder_.add_min(min);
		builder_.add_max(max);
		builder_.add_count(count);
		builder_.add_componentType(componentType);
		builder_.add_byteOffset(byteOffset);
		builder_.add_bufferView(bufferView);
		builder_.add_type(type);
		builder_.add_normalized(normalized);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<Accessor> CreateAccessorDirect(flatbuffers::FlatBufferBuilder& _fbb,
															  int32_t						  bufferView	= -1,
															  int32_t						  byteOffset	= 0,
															  int32_t						  componentType = -1,
															  bool							  normalized	= false,
															  int32_t						  count			= 1,
															  AccessorType				type = AccessorType::__UNSET,
															  const std::vector<float>* max  = nullptr,
															  const std::vector<float>* min  = nullptr,
															  const std::vector<flatbuffers::Offset<AccessorSparse>>* sparse = nullptr,
															  const char*				  name		 = nullptr,
															  const std::vector<uint8_t>* extensions = nullptr,
															  const std::vector<uint8_t>* extras	 = nullptr)
	{
		return glTF_2_0::CreateAccessor(_fbb,
										bufferView,
										byteOffset,
										componentType,
										normalized,
										count,
										type,
										max ? _fbb.CreateVector<float>(*max) : 0,
										min ? _fbb.CreateVector<float>(*min) : 0,
										sparse ? _fbb.CreateVector<flatbuffers::Offset<AccessorSparse>>(*sparse) : 0,
										name ? _fbb.CreateString(name) : 0,
										extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
										extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<Accessor> CreateAccessor(flatbuffers::FlatBufferBuilder&		 _fbb,
												 const AccessorT*						 _o,
												 const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	struct AssetT : public flatbuffers::NativeTable
	{
		typedef Asset							 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.AssetT";
		}
		std::string			 copyright;
		std::string			 generator;
		std::string			 version;
		std::string			 minVersion;
		std::string			 name;
		std::vector<uint8_t> extensions;
		std::vector<uint8_t> extras;
		AssetT()
		{
		}
	};

	///----------------------------------------------------------------------------
	///-- asset.schema.json
	/// Asset
	/// Metadata about the glTF asset.
	struct Asset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef AssetT							 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.Asset";
		}
		enum
		{
			VT_COPYRIGHT  = 4,
			VT_GENERATOR  = 6,
			VT_VERSION	= 8,
			VT_MINVERSION = 10,
			VT_NAME		  = 12,
			VT_EXTENSIONS = 14,
			VT_EXTRAS	 = 16
		};
		/// A copyright message suitable for display to credit the content creator.
		const flatbuffers::String* copyright() const
		{
			return GetPointer<const flatbuffers::String*>(VT_COPYRIGHT);
		}
		flatbuffers::String* mutable_copyright()
		{
			return GetPointer<flatbuffers::String*>(VT_COPYRIGHT);
		}
		/// Tool that generated this glTF model.  Useful for debugging.
		const flatbuffers::String* generator() const
		{
			return GetPointer<const flatbuffers::String*>(VT_GENERATOR);
		}
		flatbuffers::String* mutable_generator()
		{
			return GetPointer<flatbuffers::String*>(VT_GENERATOR);
		}
		/// The glTF version that this asset targets.
		/// pattern: "^[0-9]+\\.[0-9]+$"
		const flatbuffers::String* version() const
		{
			return GetPointer<const flatbuffers::String*>(VT_VERSION);
		}
		flatbuffers::String* mutable_version()
		{
			return GetPointer<flatbuffers::String*>(VT_VERSION);
		}
		/// The minimum glTF version that this asset targets.
		/// pattern": "^[0-9]+\\.[0-9]+$
		const flatbuffers::String* minVersion() const
		{
			return GetPointer<const flatbuffers::String*>(VT_MINVERSION);
		}
		flatbuffers::String* mutable_minVersion()
		{
			return GetPointer<flatbuffers::String*>(VT_MINVERSION);
		}
		///-- glTFChildOfRootProperty
		/// The user-defined name of this object.
		/// gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an
		/// accessor and a buffer could have the same name, or two accessors could even have the same name.
		const flatbuffers::String* name() const
		{
			return GetPointer<const flatbuffers::String*>(VT_NAME);
		}
		flatbuffers::String* mutable_name()
		{
			return GetPointer<flatbuffers::String*>(VT_NAME);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_COPYRIGHT) && verifier.Verify(copyright())
				   && VerifyOffset(verifier, VT_GENERATOR) && verifier.Verify(generator())
				   && VerifyOffsetRequired(verifier, VT_VERSION) && verifier.Verify(version())
				   && VerifyOffset(verifier, VT_MINVERSION) && verifier.Verify(minVersion()) && VerifyOffset(verifier, VT_NAME)
				   && verifier.Verify(name()) && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		AssetT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void	UnPackTo(AssetT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<Asset> Pack(flatbuffers::FlatBufferBuilder&		   _fbb,
											   const AssetT*						   _o,
											   const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct AssetBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_copyright(flatbuffers::Offset<flatbuffers::String> copyright)
		{
			fbb_.AddOffset(Asset::VT_COPYRIGHT, copyright);
		}
		void add_generator(flatbuffers::Offset<flatbuffers::String> generator)
		{
			fbb_.AddOffset(Asset::VT_GENERATOR, generator);
		}
		void add_version(flatbuffers::Offset<flatbuffers::String> version)
		{
			fbb_.AddOffset(Asset::VT_VERSION, version);
		}
		void add_minVersion(flatbuffers::Offset<flatbuffers::String> minVersion)
		{
			fbb_.AddOffset(Asset::VT_MINVERSION, minVersion);
		}
		void add_name(flatbuffers::Offset<flatbuffers::String> name)
		{
			fbb_.AddOffset(Asset::VT_NAME, name);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(Asset::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(Asset::VT_EXTRAS, extras);
		}
		AssetBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		AssetBuilder&			   operator=(const AssetBuilder&);
		flatbuffers::Offset<Asset> Finish()
		{
			const auto end = fbb_.EndTable(start_, 7);
			auto	   o   = flatbuffers::Offset<Asset>(end);
			fbb_.Required(o, Asset::VT_VERSION);
			return o;
		}
	};

	inline flatbuffers::Offset<Asset> CreateAsset(flatbuffers::FlatBufferBuilder&					_fbb,
												  flatbuffers::Offset<flatbuffers::String>			copyright  = 0,
												  flatbuffers::Offset<flatbuffers::String>			generator  = 0,
												  flatbuffers::Offset<flatbuffers::String>			version	= 0,
												  flatbuffers::Offset<flatbuffers::String>			minVersion = 0,
												  flatbuffers::Offset<flatbuffers::String>			name	   = 0,
												  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions = 0,
												  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras	 = 0)
	{
		AssetBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_name(name);
		builder_.add_minVersion(minVersion);
		builder_.add_version(version);
		builder_.add_generator(generator);
		builder_.add_copyright(copyright);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<Asset> CreateAssetDirect(flatbuffers::FlatBufferBuilder& _fbb,
														const char*						copyright  = nullptr,
														const char*						generator  = nullptr,
														const char*						version	= nullptr,
														const char*						minVersion = nullptr,
														const char*						name	   = nullptr,
														const std::vector<uint8_t>*		extensions = nullptr,
														const std::vector<uint8_t>*		extras	 = nullptr)
	{
		return glTF_2_0::CreateAsset(_fbb,
									 copyright ? _fbb.CreateString(copyright) : 0,
									 generator ? _fbb.CreateString(generator) : 0,
									 version ? _fbb.CreateString(version) : 0,
									 minVersion ? _fbb.CreateString(minVersion) : 0,
									 name ? _fbb.CreateString(name) : 0,
									 extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
									 extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<Asset> CreateAsset(flatbuffers::FlatBufferBuilder&		   _fbb,
										   const AssetT*						   _o,
										   const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	struct AnimationChannelTargetT : public flatbuffers::NativeTable
	{
		typedef AnimationChannelTarget			 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.AnimationChannelTargetT";
		}
		int32_t					   node;
		AnimationChannelTargetPath path;
		std::vector<uint8_t>	   extensions;
		std::vector<uint8_t>	   extras;
		AnimationChannelTargetT() : node(-1), path(AnimationChannelTargetPath::translation)
		{
		}
	};

	/// Animation Channel Target
	/// "description": "The index of the node and TRS property that an animation channel targets."
	struct AnimationChannelTarget FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef AnimationChannelTargetT			 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.AnimationChannelTarget";
		}
		enum
		{
			VT_NODE		  = 4,
			VT_PATH		  = 6,
			VT_EXTENSIONS = 8,
			VT_EXTRAS	 = 10
		};
		/// "description": "The index of the node to target."
		int32_t node() const
		{
			return GetField<int32_t>(VT_NODE, -1);
		}
		bool mutate_node(int32_t _node)
		{
			return SetField<int32_t>(VT_NODE, _node, -1);
		}
		/// "description": "The name of the node's TRS property to modify, or the \"weights\" of the Morph Targets it
		/// instantiates."
		AnimationChannelTargetPath path() const
		{
			return static_cast<AnimationChannelTargetPath>(GetField<int16_t>(VT_PATH, 0));
		}
		bool mutate_path(AnimationChannelTargetPath _path)
		{
			return SetField<int16_t>(VT_PATH, static_cast<int16_t>(_path), 0);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_NODE) && VerifyField<int16_t>(verifier, VT_PATH)
				   && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		AnimationChannelTargetT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void UnPackTo(AnimationChannelTargetT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<AnimationChannelTarget> Pack(flatbuffers::FlatBufferBuilder&			_fbb,
																const AnimationChannelTargetT*			_o,
																const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct AnimationChannelTargetBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_node(int32_t node)
		{
			fbb_.AddElement<int32_t>(AnimationChannelTarget::VT_NODE, node, -1);
		}
		void add_path(AnimationChannelTargetPath path)
		{
			fbb_.AddElement<int16_t>(AnimationChannelTarget::VT_PATH, static_cast<int16_t>(path), 0);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(AnimationChannelTarget::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(AnimationChannelTarget::VT_EXTRAS, extras);
		}
		AnimationChannelTargetBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		AnimationChannelTargetBuilder&				operator=(const AnimationChannelTargetBuilder&);
		flatbuffers::Offset<AnimationChannelTarget> Finish()
		{
			const auto end = fbb_.EndTable(start_, 4);
			auto	   o   = flatbuffers::Offset<AnimationChannelTarget>(end);
			return o;
		}
	};

	inline flatbuffers::Offset<AnimationChannelTarget>
	CreateAnimationChannelTarget(flatbuffers::FlatBufferBuilder& _fbb,
								 int32_t						 node = -1,
								 AnimationChannelTargetPath		 path = AnimationChannelTargetPath::translation,
								 flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions = 0,
								 flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras	 = 0)
	{
		AnimationChannelTargetBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_node(node);
		builder_.add_path(path);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<AnimationChannelTarget>
	CreateAnimationChannelTargetDirect(flatbuffers::FlatBufferBuilder& _fbb,
									   int32_t						   node = -1,
									   AnimationChannelTargetPath	  path = AnimationChannelTargetPath::translation,
									   const std::vector<uint8_t>*	 extensions = nullptr,
									   const std::vector<uint8_t>*	 extras	 = nullptr)
	{
		return glTF_2_0::CreateAnimationChannelTarget(_fbb,
													  node,
													  path,
													  extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
													  extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<AnimationChannelTarget> CreateAnimationChannelTarget(flatbuffers::FlatBufferBuilder& _fbb,
																			 const AnimationChannelTargetT*  _o,
																			 const flatbuffers::rehasher_function_t* _rehasher
																			 = nullptr);

	struct AnimationChannelT : public flatbuffers::NativeTable
	{
		typedef AnimationChannel				 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.AnimationChannelT";
		}
		int32_t									 sampler;
		std::unique_ptr<AnimationChannelTargetT> target;
		std::vector<uint8_t>					 extensions;
		std::vector<uint8_t>					 extras;
		AnimationChannelT() : sampler(-1)
		{
		}
	};

	///-- animation.channel.target.schema.json --/
	///-- animation.channel.schema.json
	/// Animation Channel
	/// "description": "Targets an animation's sampler at a node's property."
	struct AnimationChannel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef AnimationChannelT				 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.AnimationChannel";
		}
		enum
		{
			VT_SAMPLER	= 4,
			VT_TARGET	 = 6,
			VT_EXTENSIONS = 8,
			VT_EXTRAS	 = 10
		};
		/// "description": "The index of a sampler in this animation used to compute the value for the target."
		/// "gltf_detailedDescription": "The index of a sampler in this animation used to compute the value for the
		/// target, e.g., a node's translation, rotation, or scale (TRS)."
		int32_t sampler() const
		{
			return GetField<int32_t>(VT_SAMPLER, -1);
		}
		bool mutate_sampler(int32_t _sampler)
		{
			return SetField<int32_t>(VT_SAMPLER, _sampler, -1);
		}
		/// "description": "The index of the node and TRS property to target."
		const AnimationChannelTarget* target() const
		{
			return GetPointer<const AnimationChannelTarget*>(VT_TARGET);
		}
		AnimationChannelTarget* mutable_target()
		{
			return GetPointer<AnimationChannelTarget*>(VT_TARGET);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_SAMPLER)
				   && VerifyOffsetRequired(verifier, VT_TARGET) && verifier.VerifyTable(target())
				   && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		AnimationChannelT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void UnPackTo(AnimationChannelT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<AnimationChannel> Pack(flatbuffers::FlatBufferBuilder&		  _fbb,
														  const AnimationChannelT*				  _o,
														  const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct AnimationChannelBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_sampler(int32_t sampler)
		{
			fbb_.AddElement<int32_t>(AnimationChannel::VT_SAMPLER, sampler, -1);
		}
		void add_target(flatbuffers::Offset<AnimationChannelTarget> target)
		{
			fbb_.AddOffset(AnimationChannel::VT_TARGET, target);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(AnimationChannel::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(AnimationChannel::VT_EXTRAS, extras);
		}
		AnimationChannelBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		AnimationChannelBuilder&			  operator=(const AnimationChannelBuilder&);
		flatbuffers::Offset<AnimationChannel> Finish()
		{
			const auto end = fbb_.EndTable(start_, 4);
			auto	   o   = flatbuffers::Offset<AnimationChannel>(end);
			fbb_.Required(o, AnimationChannel::VT_TARGET);
			return o;
		}
	};

	inline flatbuffers::Offset<AnimationChannel> CreateAnimationChannel(flatbuffers::FlatBufferBuilder& _fbb,
																		int32_t							sampler = -1,
																		flatbuffers::Offset<AnimationChannelTarget> target = 0,
																		flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions = 0,
																		flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras = 0)
	{
		AnimationChannelBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_target(target);
		builder_.add_sampler(sampler);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<AnimationChannel> CreateAnimationChannelDirect(flatbuffers::FlatBufferBuilder& _fbb,
																			  int32_t sampler = -1,
																			  flatbuffers::Offset<AnimationChannelTarget> target = 0,
																			  const std::vector<uint8_t>* extensions = nullptr,
																			  const std::vector<uint8_t>* extras = nullptr)
	{
		return glTF_2_0::CreateAnimationChannel(_fbb,
												sampler,
												target,
												extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
												extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<AnimationChannel> CreateAnimationChannel(flatbuffers::FlatBufferBuilder&		 _fbb,
																 const AnimationChannelT*				 _o,
																 const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	struct AnimationSamplerT : public flatbuffers::NativeTable
	{
		typedef AnimationSampler				 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.AnimationSamplerT";
		}
		int32_t								   input;
		AnimationSamplerInterpolationAlgorithm interpolation;
		int32_t								   output;
		std::vector<uint8_t>				   extensions;
		std::vector<uint8_t>				   extras;
		AnimationSamplerT() : input(-1), interpolation(AnimationSamplerInterpolationAlgorithm::LINEAR), output(-1)
		{
		}
	};

	/// Animation Sampler
	/// "description": "Combines input and output accessors with an interpolation algorithm to define a keyframe graph
	/// (but not its target)."
	struct AnimationSampler FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef AnimationSamplerT				 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.AnimationSampler";
		}
		enum
		{
			VT_INPUT		 = 4,
			VT_INTERPOLATION = 6,
			VT_OUTPUT		 = 8,
			VT_EXTENSIONS	= 10,
			VT_EXTRAS		 = 12
		};
		/// "description": "The index of an accessor containing keyframe input values, e.g., time."
		/// "gltf_detailedDescription": "The index of an accessor containing keyframe input values, e.g., time. That
		/// accessor must have componentType `FLOAT`. The values represent time in seconds with `time[0] >= 0.0`, and
		/// strictly increasing values, i.e., `time[n + 1] > time[n]`."
		int32_t input() const
		{
			return GetField<int32_t>(VT_INPUT, -1);
		}
		bool mutate_input(int32_t _input)
		{
			return SetField<int32_t>(VT_INPUT, _input, -1);
		}
		/// "description": "Interpolation algorithm."
		/// "gltf_detailedDescription": "Interpolation algorithm."
		AnimationSamplerInterpolationAlgorithm interpolation() const
		{
			return static_cast<AnimationSamplerInterpolationAlgorithm>(GetField<int16_t>(VT_INTERPOLATION, 0));
		}
		bool mutate_interpolation(AnimationSamplerInterpolationAlgorithm _interpolation)
		{
			return SetField<int16_t>(VT_INTERPOLATION, static_cast<int16_t>(_interpolation), 0);
		}
		/// "description": "The index of an accessor, containing keyframe output values."
		/// "gltf_detailedDescription": "The index of an accessor containing keyframe output values. When targeting TRS
		/// target, the `accessor.componentType` of the output values must be `FLOAT`. When targeting morph weights, the
		/// `accessor.componentType` of the output values must be `FLOAT` or normalized integer where each output
		/// element stores values with a count equal to the number of morph targets."
		int32_t output() const
		{
			return GetField<int32_t>(VT_OUTPUT, -1);
		}
		bool mutate_output(int32_t _output)
		{
			return SetField<int32_t>(VT_OUTPUT, _output, -1);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_INPUT)
				   && VerifyField<int16_t>(verifier, VT_INTERPOLATION) && VerifyField<int32_t>(verifier, VT_OUTPUT)
				   && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		AnimationSamplerT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void UnPackTo(AnimationSamplerT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<AnimationSampler> Pack(flatbuffers::FlatBufferBuilder&		  _fbb,
														  const AnimationSamplerT*				  _o,
														  const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct AnimationSamplerBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_input(int32_t input)
		{
			fbb_.AddElement<int32_t>(AnimationSampler::VT_INPUT, input, -1);
		}
		void add_interpolation(AnimationSamplerInterpolationAlgorithm interpolation)
		{
			fbb_.AddElement<int16_t>(AnimationSampler::VT_INTERPOLATION, static_cast<int16_t>(interpolation), 0);
		}
		void add_output(int32_t output)
		{
			fbb_.AddElement<int32_t>(AnimationSampler::VT_OUTPUT, output, -1);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(AnimationSampler::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(AnimationSampler::VT_EXTRAS, extras);
		}
		AnimationSamplerBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		AnimationSamplerBuilder&			  operator=(const AnimationSamplerBuilder&);
		flatbuffers::Offset<AnimationSampler> Finish()
		{
			const auto end = fbb_.EndTable(start_, 5);
			auto	   o   = flatbuffers::Offset<AnimationSampler>(end);
			return o;
		}
	};

	inline flatbuffers::Offset<AnimationSampler>
	CreateAnimationSampler(flatbuffers::FlatBufferBuilder& _fbb,
						   int32_t						   input				= -1,
						   AnimationSamplerInterpolationAlgorithm interpolation = AnimationSamplerInterpolationAlgorithm::LINEAR,
						   int32_t								  output				= -1,
						   flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions = 0,
						   flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras		= 0)
	{
		AnimationSamplerBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_output(output);
		builder_.add_input(input);
		builder_.add_interpolation(interpolation);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<AnimationSampler> CreateAnimationSamplerDirect(flatbuffers::FlatBufferBuilder& _fbb,
																			  int32_t input = -1,
																			  AnimationSamplerInterpolationAlgorithm interpolation
																			  = AnimationSamplerInterpolationAlgorithm::LINEAR,
																			  int32_t					  output = -1,
																			  const std::vector<uint8_t>* extensions = nullptr,
																			  const std::vector<uint8_t>* extras = nullptr)
	{
		return glTF_2_0::CreateAnimationSampler(_fbb,
												input,
												interpolation,
												output,
												extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
												extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<AnimationSampler> CreateAnimationSampler(flatbuffers::FlatBufferBuilder&		 _fbb,
																 const AnimationSamplerT*				 _o,
																 const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	struct AnimationT : public flatbuffers::NativeTable
	{
		typedef Animation						 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.AnimationT";
		}
		std::vector<std::unique_ptr<AnimationChannelT>> channels;
		std::vector<std::unique_ptr<AnimationSamplerT>> samplers;
		std::string										name;
		std::vector<uint8_t>							extensions;
		std::vector<uint8_t>							extras;
		AnimationT()
		{
		}
	};

	///-- animation.sampler.schema.json --/
	///-- animation.schema.json
	/// Animation
	/// "description": "A keyframe animation."
	struct Animation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef AnimationT						 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.Animation";
		}
		enum
		{
			VT_CHANNELS   = 4,
			VT_SAMPLERS   = 6,
			VT_NAME		  = 8,
			VT_EXTENSIONS = 10,
			VT_EXTRAS	 = 12
		};
		/// "description": "An array of channels, each of which targets an animation's sampler at a node's property.
		/// Different channels of the same animation can't have equal targets."
		const flatbuffers::Vector<flatbuffers::Offset<AnimationChannel>>* channels() const
		{
			return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimationChannel>>*>(VT_CHANNELS);
		}
		flatbuffers::Vector<flatbuffers::Offset<AnimationChannel>>* mutable_channels()
		{
			return GetPointer<flatbuffers::Vector<flatbuffers::Offset<AnimationChannel>>*>(VT_CHANNELS);
		}
		/// "description": "An array of samplers that combines input and output accessors with an interpolation
		/// algorithm to define a keyframe graph (but not its target)."
		const flatbuffers::Vector<flatbuffers::Offset<AnimationSampler>>* samplers() const
		{
			return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimationSampler>>*>(VT_SAMPLERS);
		}
		flatbuffers::Vector<flatbuffers::Offset<AnimationSampler>>* mutable_samplers()
		{
			return GetPointer<flatbuffers::Vector<flatbuffers::Offset<AnimationSampler>>*>(VT_SAMPLERS);
		}
		///-- glTFChildOfRootProperty
		/// The user-defined name of this object.
		/// gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an
		/// accessor and a buffer could have the same name, or two accessors could even have the same name.
		const flatbuffers::String* name() const
		{
			return GetPointer<const flatbuffers::String*>(VT_NAME);
		}
		flatbuffers::String* mutable_name()
		{
			return GetPointer<flatbuffers::String*>(VT_NAME);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_CHANNELS) && verifier.Verify(channels())
				   && verifier.VerifyVectorOfTables(channels()) && VerifyOffsetRequired(verifier, VT_SAMPLERS)
				   && verifier.Verify(samplers()) && verifier.VerifyVectorOfTables(samplers()) && VerifyOffset(verifier, VT_NAME)
				   && verifier.Verify(name()) && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		AnimationT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void		UnPackTo(AnimationT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<Animation> Pack(flatbuffers::FlatBufferBuilder&		   _fbb,
												   const AnimationT*					   _o,
												   const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct AnimationBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void add_channels(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationChannel>>> channels)
		{
			fbb_.AddOffset(Animation::VT_CHANNELS, channels);
		}
		void add_samplers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationSampler>>> samplers)
		{
			fbb_.AddOffset(Animation::VT_SAMPLERS, samplers);
		}
		void add_name(flatbuffers::Offset<flatbuffers::String> name)
		{
			fbb_.AddOffset(Animation::VT_NAME, name);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(Animation::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(Animation::VT_EXTRAS, extras);
		}
		AnimationBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		AnimationBuilder&			   operator=(const AnimationBuilder&);
		flatbuffers::Offset<Animation> Finish()
		{
			const auto end = fbb_.EndTable(start_, 5);
			auto	   o   = flatbuffers::Offset<Animation>(end);
			fbb_.Required(o, Animation::VT_CHANNELS);
			fbb_.Required(o, Animation::VT_SAMPLERS);
			return o;
		}
	};

	inline flatbuffers::Offset<Animation>
	CreateAnimation(flatbuffers::FlatBufferBuilder&													_fbb,
					flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationChannel>>> channels   = 0,
					flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationSampler>>> samplers   = 0,
					flatbuffers::Offset<flatbuffers::String>										name	   = 0,
					flatbuffers::Offset<flatbuffers::Vector<uint8_t>>								extensions = 0,
					flatbuffers::Offset<flatbuffers::Vector<uint8_t>>								extras	 = 0)
	{
		AnimationBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_name(name);
		builder_.add_samplers(samplers);
		builder_.add_channels(channels);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<Animation> CreateAnimationDirect(flatbuffers::FlatBufferBuilder& _fbb,
																const std::vector<flatbuffers::Offset<AnimationChannel>>* channels = nullptr,
																const std::vector<flatbuffers::Offset<AnimationSampler>>* samplers = nullptr,
																const char*					name	   = nullptr,
																const std::vector<uint8_t>* extensions = nullptr,
																const std::vector<uint8_t>* extras	 = nullptr)
	{
		return glTF_2_0::CreateAnimation(_fbb,
										 channels ? _fbb.CreateVector<flatbuffers::Offset<AnimationChannel>>(*channels) : 0,
										 samplers ? _fbb.CreateVector<flatbuffers::Offset<AnimationSampler>>(*samplers) : 0,
										 name ? _fbb.CreateString(name) : 0,
										 extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
										 extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<Animation> CreateAnimation(flatbuffers::FlatBufferBuilder&		   _fbb,
												   const AnimationT*					   _o,
												   const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	struct BufferT : public flatbuffers::NativeTable
	{
		typedef Buffer							 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.BufferT";
		}
		std::string			 uri;
		int32_t				 byteLength;
		std::string			 name;
		std::vector<uint8_t> extensions;
		std::vector<uint8_t> extras;
		BufferT() : byteLength(0)
		{
		}
	};

	///-- animation.schema.json --/
	///----------------------------------------------------------------------------
	///-- buffer.schema.json
	/// Buffer
	/// "description": "A buffer points to binary geometry, animation, or skins."
	struct Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef BufferT							 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.Buffer";
		}
		enum
		{
			VT_URI		  = 4,
			VT_BYTELENGTH = 6,
			VT_NAME		  = 8,
			VT_EXTENSIONS = 10,
			VT_EXTRAS	 = 12
		};
		/// "description": "The uri of the buffer."
		/// "format": "uriref"
		/// "gltf_detailedDescription": "The uri of the buffer.  Relative paths are relative to the .gltf file.  Instead
		/// of referencing an external file, the uri can also be a data-uri." "gltf_uriType": "application"
		const flatbuffers::String* uri() const
		{
			return GetPointer<const flatbuffers::String*>(VT_URI);
		}
		flatbuffers::String* mutable_uri()
		{
			return GetPointer<flatbuffers::String*>(VT_URI);
		}
		/// "description": "The length of the buffer in bytes."
		int32_t byteLength() const
		{
			return GetField<int32_t>(VT_BYTELENGTH, 0);
		}
		bool mutate_byteLength(int32_t _byteLength)
		{
			return SetField<int32_t>(VT_BYTELENGTH, _byteLength, 0);
		}
		///-- glTFChildOfRootProperty
		/// The user-defined name of this object.
		/// gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an
		/// accessor and a buffer could have the same name, or two accessors could even have the same name.
		const flatbuffers::String* name() const
		{
			return GetPointer<const flatbuffers::String*>(VT_NAME);
		}
		flatbuffers::String* mutable_name()
		{
			return GetPointer<flatbuffers::String*>(VT_NAME);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_URI) && verifier.Verify(uri())
				   && VerifyField<int32_t>(verifier, VT_BYTELENGTH) && VerifyOffset(verifier, VT_NAME)
				   && verifier.Verify(name()) && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		BufferT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void	 UnPackTo(BufferT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<Buffer> Pack(flatbuffers::FlatBufferBuilder&			_fbb,
												const BufferT*							_o,
												const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct BufferBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_uri(flatbuffers::Offset<flatbuffers::String> uri)
		{
			fbb_.AddOffset(Buffer::VT_URI, uri);
		}
		void add_byteLength(int32_t byteLength)
		{
			fbb_.AddElement<int32_t>(Buffer::VT_BYTELENGTH, byteLength, 0);
		}
		void add_name(flatbuffers::Offset<flatbuffers::String> name)
		{
			fbb_.AddOffset(Buffer::VT_NAME, name);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(Buffer::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(Buffer::VT_EXTRAS, extras);
		}
		BufferBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		BufferBuilder&				operator=(const BufferBuilder&);
		flatbuffers::Offset<Buffer> Finish()
		{
			const auto end = fbb_.EndTable(start_, 5);
			auto	   o   = flatbuffers::Offset<Buffer>(end);
			return o;
		}
	};

	inline flatbuffers::Offset<Buffer> CreateBuffer(flatbuffers::FlatBufferBuilder&					  _fbb,
													flatbuffers::Offset<flatbuffers::String>		  uri		 = 0,
													int32_t											  byteLength = 0,
													flatbuffers::Offset<flatbuffers::String>		  name		 = 0,
													flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions = 0,
													flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras	 = 0)
	{
		BufferBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_name(name);
		builder_.add_byteLength(byteLength);
		builder_.add_uri(uri);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<Buffer> CreateBufferDirect(flatbuffers::FlatBufferBuilder& _fbb,
														  const char*					  uri		 = nullptr,
														  int32_t						  byteLength = 0,
														  const char*					  name		 = nullptr,
														  const std::vector<uint8_t>*	 extensions = nullptr,
														  const std::vector<uint8_t>*	 extras	 = nullptr)
	{
		return glTF_2_0::CreateBuffer(_fbb,
									  uri ? _fbb.CreateString(uri) : 0,
									  byteLength,
									  name ? _fbb.CreateString(name) : 0,
									  extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
									  extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<Buffer> CreateBuffer(flatbuffers::FlatBufferBuilder&		 _fbb,
											 const BufferT*							 _o,
											 const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	struct BufferViewT : public flatbuffers::NativeTable
	{
		typedef BufferView						 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.BufferViewT";
		}
		int32_t				 buffer;
		int32_t				 byteOffset;
		int32_t				 byteLength;
		int32_t				 byteStride;
		int32_t				 target;
		std::string			 name;
		std::vector<uint8_t> extensions;
		std::vector<uint8_t> extras;
		BufferViewT() : buffer(-1), byteOffset(0), byteLength(0), byteStride(0), target(-1)
		{
		}
	};

	/// Buffer View
	/// "description": "A view into a buffer generally representing a subset of the buffer."
	struct BufferView FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef BufferViewT						 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.BufferView";
		}
		enum
		{
			VT_BUFFER	 = 4,
			VT_BYTEOFFSET = 6,
			VT_BYTELENGTH = 8,
			VT_BYTESTRIDE = 10,
			VT_TARGET	 = 12,
			VT_NAME		  = 14,
			VT_EXTENSIONS = 16,
			VT_EXTRAS	 = 18
		};
		/// "description": "The index of the buffer."
		int32_t buffer() const
		{
			return GetField<int32_t>(VT_BUFFER, -1);
		}
		bool mutate_buffer(int32_t _buffer)
		{
			return SetField<int32_t>(VT_BUFFER, _buffer, -1);
		}
		/// "description": "The offset into the buffer in bytes."
		int32_t byteOffset() const
		{
			return GetField<int32_t>(VT_BYTEOFFSET, 0);
		}
		bool mutate_byteOffset(int32_t _byteOffset)
		{
			return SetField<int32_t>(VT_BYTEOFFSET, _byteOffset, 0);
		}
		int32_t byteLength() const
		{
			return GetField<int32_t>(VT_BYTELENGTH, 0);
		}
		bool mutate_byteLength(int32_t _byteLength)
		{
			return SetField<int32_t>(VT_BYTELENGTH, _byteLength, 0);
		}
		/// "description": "The stride, in bytes."
		/// "minimum": 4
		/// "maximum": 252
		/// "multipleOf": 4
		/// "gltf_detailedDescription": "The stride, in bytes, between vertex attributes.  When this is not defined,
		/// data is tightly packed. When two or more accessors use the same bufferView, this field must be defined."
		/// "gltf_webgl": "`vertexAttribPointer()` stride parameter"
		int32_t byteStride() const
		{
			return GetField<int32_t>(VT_BYTESTRIDE, 0);
		}
		bool mutate_byteStride(int32_t _byteStride)
		{
			return SetField<int32_t>(VT_BYTESTRIDE, _byteStride, 0);
		}
		/// "description": "The target that the GPU buffer should be bound to."
		/// "gltf_webgl": "`bindBuffer()`"
		int32_t target() const
		{
			return GetField<int32_t>(VT_TARGET, -1);
		}
		bool mutate_target(int32_t _target)
		{
			return SetField<int32_t>(VT_TARGET, _target, -1);
		}
		///-- glTFChildOfRootProperty
		/// The user-defined name of this object.
		/// gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an
		/// accessor and a buffer could have the same name, or two accessors could even have the same name.
		const flatbuffers::String* name() const
		{
			return GetPointer<const flatbuffers::String*>(VT_NAME);
		}
		flatbuffers::String* mutable_name()
		{
			return GetPointer<flatbuffers::String*>(VT_NAME);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_BUFFER)
				   && VerifyField<int32_t>(verifier, VT_BYTEOFFSET) && VerifyField<int32_t>(verifier, VT_BYTELENGTH)
				   && VerifyField<int32_t>(verifier, VT_BYTESTRIDE) && VerifyField<int32_t>(verifier, VT_TARGET)
				   && VerifyOffset(verifier, VT_NAME) && verifier.Verify(name())
				   && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		BufferViewT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void		 UnPackTo(BufferViewT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<BufferView> Pack(flatbuffers::FlatBufferBuilder&			_fbb,
													const BufferViewT*						_o,
													const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct BufferViewBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_buffer(int32_t buffer)
		{
			fbb_.AddElement<int32_t>(BufferView::VT_BUFFER, buffer, -1);
		}
		void add_byteOffset(int32_t byteOffset)
		{
			fbb_.AddElement<int32_t>(BufferView::VT_BYTEOFFSET, byteOffset, 0);
		}
		void add_byteLength(int32_t byteLength)
		{
			fbb_.AddElement<int32_t>(BufferView::VT_BYTELENGTH, byteLength, 0);
		}
		void add_byteStride(int32_t byteStride)
		{
			fbb_.AddElement<int32_t>(BufferView::VT_BYTESTRIDE, byteStride, 0);
		}
		void add_target(int32_t target)
		{
			fbb_.AddElement<int32_t>(BufferView::VT_TARGET, target, -1);
		}
		void add_name(flatbuffers::Offset<flatbuffers::String> name)
		{
			fbb_.AddOffset(BufferView::VT_NAME, name);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(BufferView::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(BufferView::VT_EXTRAS, extras);
		}
		BufferViewBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		BufferViewBuilder&				operator=(const BufferViewBuilder&);
		flatbuffers::Offset<BufferView> Finish()
		{
			const auto end = fbb_.EndTable(start_, 8);
			auto	   o   = flatbuffers::Offset<BufferView>(end);
			return o;
		}
	};

	inline flatbuffers::Offset<BufferView> CreateBufferView(flatbuffers::FlatBufferBuilder&			 _fbb,
															int32_t									 buffer		= -1,
															int32_t									 byteOffset = 0,
															int32_t									 byteLength = 0,
															int32_t									 byteStride = 0,
															int32_t									 target		= -1,
															flatbuffers::Offset<flatbuffers::String> name		= 0,
															flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions = 0,
															flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras = 0)
	{
		BufferViewBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_name(name);
		builder_.add_target(target);
		builder_.add_byteStride(byteStride);
		builder_.add_byteLength(byteLength);
		builder_.add_byteOffset(byteOffset);
		builder_.add_buffer(buffer);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<BufferView> CreateBufferViewDirect(flatbuffers::FlatBufferBuilder& _fbb,
																  int32_t						  buffer	 = -1,
																  int32_t						  byteOffset = 0,
																  int32_t						  byteLength = 0,
																  int32_t						  byteStride = 0,
																  int32_t						  target	 = -1,
																  const char*					  name		 = nullptr,
																  const std::vector<uint8_t>*	 extensions = nullptr,
																  const std::vector<uint8_t>*	 extras	 = nullptr)
	{
		return glTF_2_0::CreateBufferView(_fbb,
										  buffer,
										  byteOffset,
										  byteLength,
										  byteStride,
										  target,
										  name ? _fbb.CreateString(name) : 0,
										  extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
										  extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<BufferView> CreateBufferView(flatbuffers::FlatBufferBuilder&		 _fbb,
													 const BufferViewT*						 _o,
													 const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	struct CameraOrthographicT : public flatbuffers::NativeTable
	{
		typedef CameraOrthographic				 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.CameraOrthographicT";
		}
		float				 xmag;
		float				 ymag;
		float				 zfar;
		float				 znear;
		std::vector<uint8_t> extensions;
		std::vector<uint8_t> extras;
		CameraOrthographicT() : xmag(0.0f), ymag(0.0f), zfar(0.0f), znear(0.0f)
		{
		}
	};

	///-- bufferView.schema.json --/
	///----------------------------------------------------------------------------
	///-- camera.orthographic.schema.json
	/// Camera Orthographic
	/// "description": "An orthographic camera containing properties to create an orthographic projection matrix."
	struct CameraOrthographic FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef CameraOrthographicT				 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.CameraOrthographic";
		}
		enum
		{
			VT_XMAG		  = 4,
			VT_YMAG		  = 6,
			VT_ZFAR		  = 8,
			VT_ZNEAR	  = 10,
			VT_EXTENSIONS = 12,
			VT_EXTRAS	 = 14
		};
		/// "description": "The floating-point horizontal magnification of the view. Must not be zero."
		float xmag() const
		{
			return GetField<float>(VT_XMAG, 0.0f);
		}
		bool mutate_xmag(float _xmag)
		{
			return SetField<float>(VT_XMAG, _xmag, 0.0f);
		}
		/// "description": "The floating-point vertical magnification of the view. Must not be zero."
		float ymag() const
		{
			return GetField<float>(VT_YMAG, 0.0f);
		}
		bool mutate_ymag(float _ymag)
		{
			return SetField<float>(VT_YMAG, _ymag, 0.0f);
		}
		/// "description": "The floating-point distance to the far clipping plane. `zfar` must be greater than `znear`."
		float zfar() const
		{
			return GetField<float>(VT_ZFAR, 0.0f);
		}
		bool mutate_zfar(float _zfar)
		{
			return SetField<float>(VT_ZFAR, _zfar, 0.0f);
		}
		/// "description": "The floating-point distance to the near clipping plane."
		float znear() const
		{
			return GetField<float>(VT_ZNEAR, 0.0f);
		}
		bool mutate_znear(float _znear)
		{
			return SetField<float>(VT_ZNEAR, _znear, 0.0f);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_XMAG) && VerifyField<float>(verifier, VT_YMAG)
				   && VerifyField<float>(verifier, VT_ZFAR) && VerifyField<float>(verifier, VT_ZNEAR)
				   && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		CameraOrthographicT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void UnPackTo(CameraOrthographicT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<CameraOrthographic> Pack(flatbuffers::FlatBufferBuilder&			_fbb,
															const CameraOrthographicT*				_o,
															const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct CameraOrthographicBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_xmag(float xmag)
		{
			fbb_.AddElement<float>(CameraOrthographic::VT_XMAG, xmag, 0.0f);
		}
		void add_ymag(float ymag)
		{
			fbb_.AddElement<float>(CameraOrthographic::VT_YMAG, ymag, 0.0f);
		}
		void add_zfar(float zfar)
		{
			fbb_.AddElement<float>(CameraOrthographic::VT_ZFAR, zfar, 0.0f);
		}
		void add_znear(float znear)
		{
			fbb_.AddElement<float>(CameraOrthographic::VT_ZNEAR, znear, 0.0f);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(CameraOrthographic::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(CameraOrthographic::VT_EXTRAS, extras);
		}
		CameraOrthographicBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		CameraOrthographicBuilder&				operator=(const CameraOrthographicBuilder&);
		flatbuffers::Offset<CameraOrthographic> Finish()
		{
			const auto end = fbb_.EndTable(start_, 6);
			auto	   o   = flatbuffers::Offset<CameraOrthographic>(end);
			return o;
		}
	};

	inline flatbuffers::Offset<CameraOrthographic>
	CreateCameraOrthographic(flatbuffers::FlatBufferBuilder&				   _fbb,
							 float											   xmag		  = 0.0f,
							 float											   ymag		  = 0.0f,
							 float											   zfar		  = 0.0f,
							 float											   znear	  = 0.0f,
							 flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions = 0,
							 flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras	 = 0)
	{
		CameraOrthographicBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_znear(znear);
		builder_.add_zfar(zfar);
		builder_.add_ymag(ymag);
		builder_.add_xmag(xmag);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<CameraOrthographic> CreateCameraOrthographicDirect(flatbuffers::FlatBufferBuilder& _fbb,
																				  float xmag  = 0.0f,
																				  float ymag  = 0.0f,
																				  float zfar  = 0.0f,
																				  float znear = 0.0f,
																				  const std::vector<uint8_t>* extensions = nullptr,
																				  const std::vector<uint8_t>* extras = nullptr)
	{
		return glTF_2_0::CreateCameraOrthographic(_fbb,
												  xmag,
												  ymag,
												  zfar,
												  znear,
												  extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
												  extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<CameraOrthographic> CreateCameraOrthographic(flatbuffers::FlatBufferBuilder& _fbb,
																	 const CameraOrthographicT*		 _o,
																	 const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	struct CameraPerspectiveT : public flatbuffers::NativeTable
	{
		typedef CameraPerspective				 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.CameraPerspectiveT";
		}
		float				 aspectRatio;
		float				 yfov;
		float				 zfar;
		float				 znear;
		std::vector<uint8_t> extensions;
		std::vector<uint8_t> extras;
		CameraPerspectiveT() : aspectRatio(0.0f), yfov(0.0f), zfar(0.0f), znear(0.0f)
		{
		}
	};

	///-- camera.orthographic.schema.json --/
	///-- camera.perspective.schema.json
	/// Camera Perspective
	/// "description": "A perspective camera containing properties to create a perspective projection matrix."
	struct CameraPerspective FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef CameraPerspectiveT				 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.CameraPerspective";
		}
		enum
		{
			VT_ASPECTRATIO = 4,
			VT_YFOV		   = 6,
			VT_ZFAR		   = 8,
			VT_ZNEAR	   = 10,
			VT_EXTENSIONS  = 12,
			VT_EXTRAS	  = 14
		};
		/// "description": "The floating-point aspect ratio of the field of view."
		/// "gltf_detailedDescription": "The floating-point aspect ratio of the field of view. When this is undefined,
		/// the aspect ratio of the canvas is used."
		float aspectRatio() const
		{
			return GetField<float>(VT_ASPECTRATIO, 0.0f);
		}
		bool mutate_aspectRatio(float _aspectRatio)
		{
			return SetField<float>(VT_ASPECTRATIO, _aspectRatio, 0.0f);
		}
		/// "description": "The floating-point vertical field of view in radians."
		float yfov() const
		{
			return GetField<float>(VT_YFOV, 0.0f);
		}
		bool mutate_yfov(float _yfov)
		{
			return SetField<float>(VT_YFOV, _yfov, 0.0f);
		}
		/// "description": "The floating-point distance to the far clipping plane."
		/// "gltf_detailedDescription": "The floating-point distance to the far clipping plane. When defined, `zfar`
		/// must be greater than `znear`. If `zfar` is undefined, runtime must use infinite projection matrix."
		float zfar() const
		{
			return GetField<float>(VT_ZFAR, 0.0f);
		}
		bool mutate_zfar(float _zfar)
		{
			return SetField<float>(VT_ZFAR, _zfar, 0.0f);
		}
		/// "description": "The floating-point distance to the near clipping plane."
		/// "gltf_detailedDescription": "The floating-point distance to the near clipping plane."
		float znear() const
		{
			return GetField<float>(VT_ZNEAR, 0.0f);
		}
		bool mutate_znear(float _znear)
		{
			return SetField<float>(VT_ZNEAR, _znear, 0.0f);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_ASPECTRATIO)
				   && VerifyField<float>(verifier, VT_YFOV) && VerifyField<float>(verifier, VT_ZFAR)
				   && VerifyField<float>(verifier, VT_ZNEAR) && VerifyOffset(verifier, VT_EXTENSIONS)
				   && verifier.Verify(extensions()) && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras())
				   && verifier.EndTable();
		}
		CameraPerspectiveT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void UnPackTo(CameraPerspectiveT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<CameraPerspective> Pack(flatbuffers::FlatBufferBuilder&		   _fbb,
														   const CameraPerspectiveT*			   _o,
														   const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct CameraPerspectiveBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_aspectRatio(float aspectRatio)
		{
			fbb_.AddElement<float>(CameraPerspective::VT_ASPECTRATIO, aspectRatio, 0.0f);
		}
		void add_yfov(float yfov)
		{
			fbb_.AddElement<float>(CameraPerspective::VT_YFOV, yfov, 0.0f);
		}
		void add_zfar(float zfar)
		{
			fbb_.AddElement<float>(CameraPerspective::VT_ZFAR, zfar, 0.0f);
		}
		void add_znear(float znear)
		{
			fbb_.AddElement<float>(CameraPerspective::VT_ZNEAR, znear, 0.0f);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(CameraPerspective::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(CameraPerspective::VT_EXTRAS, extras);
		}
		CameraPerspectiveBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		CameraPerspectiveBuilder&			   operator=(const CameraPerspectiveBuilder&);
		flatbuffers::Offset<CameraPerspective> Finish()
		{
			const auto end = fbb_.EndTable(start_, 6);
			auto	   o   = flatbuffers::Offset<CameraPerspective>(end);
			return o;
		}
	};

	inline flatbuffers::Offset<CameraPerspective> CreateCameraPerspective(flatbuffers::FlatBufferBuilder& _fbb,
																		  float aspectRatio = 0.0f,
																		  float yfov		= 0.0f,
																		  float zfar		= 0.0f,
																		  float znear		= 0.0f,
																		  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions = 0,
																		  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras = 0)
	{
		CameraPerspectiveBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_znear(znear);
		builder_.add_zfar(zfar);
		builder_.add_yfov(yfov);
		builder_.add_aspectRatio(aspectRatio);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<CameraPerspective> CreateCameraPerspectiveDirect(flatbuffers::FlatBufferBuilder& _fbb,
																				float aspectRatio = 0.0f,
																				float yfov		  = 0.0f,
																				float zfar		  = 0.0f,
																				float znear		  = 0.0f,
																				const std::vector<uint8_t>* extensions = nullptr,
																				const std::vector<uint8_t>* extras = nullptr)
	{
		return glTF_2_0::CreateCameraPerspective(_fbb,
												 aspectRatio,
												 yfov,
												 zfar,
												 znear,
												 extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
												 extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<CameraPerspective> CreateCameraPerspective(flatbuffers::FlatBufferBuilder&		   _fbb,
																   const CameraPerspectiveT*			   _o,
																   const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	struct CameraT : public flatbuffers::NativeTable
	{
		typedef Camera							 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.CameraT";
		}
		std::unique_ptr<CameraOrthographicT> orthographic;
		std::unique_ptr<CameraPerspectiveT>  perspective;
		CameraType							 type;
		std::string							 name;
		std::vector<uint8_t>				 extensions;
		std::vector<uint8_t>				 extras;
		CameraT() : type(CameraType::perspective)
		{
		}
	};

	struct Camera FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef CameraT							 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.Camera";
		}
		enum
		{
			VT_ORTHOGRAPHIC = 4,
			VT_PERSPECTIVE  = 6,
			VT_TYPE			= 8,
			VT_NAME			= 10,
			VT_EXTENSIONS   = 12,
			VT_EXTRAS		= 14
		};
		/// "description": "An orthographic camera containing properties to create an orthographic projection matrix."
		const CameraOrthographic* orthographic() const
		{
			return GetPointer<const CameraOrthographic*>(VT_ORTHOGRAPHIC);
		}
		CameraOrthographic* mutable_orthographic()
		{
			return GetPointer<CameraOrthographic*>(VT_ORTHOGRAPHIC);
		}
		/// "description": "A perspective camera containing properties to create a perspective projection matrix."
		const CameraPerspective* perspective() const
		{
			return GetPointer<const CameraPerspective*>(VT_PERSPECTIVE);
		}
		CameraPerspective* mutable_perspective()
		{
			return GetPointer<CameraPerspective*>(VT_PERSPECTIVE);
		}
		/// "description": "Specifies if the camera uses a perspective or orthographic projection."
		/// "gltf_detailedDescription": "Specifies if the camera uses a perspective or orthographic projection.  Based
		/// on this, either the camera's `perspective` or `orthographic` property will be defined."
		CameraType type() const
		{
			return static_cast<CameraType>(GetField<int16_t>(VT_TYPE, 0));
		}
		bool mutate_type(CameraType _type)
		{
			return SetField<int16_t>(VT_TYPE, static_cast<int16_t>(_type), 0);
		}
		///-- glTFChildOfRootProperty
		/// The user-defined name of this object.
		/// gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an
		/// accessor and a buffer could have the same name, or two accessors could even have the same name.
		const flatbuffers::String* name() const
		{
			return GetPointer<const flatbuffers::String*>(VT_NAME);
		}
		flatbuffers::String* mutable_name()
		{
			return GetPointer<flatbuffers::String*>(VT_NAME);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ORTHOGRAPHIC)
				   && verifier.VerifyTable(orthographic()) && VerifyOffset(verifier, VT_PERSPECTIVE)
				   && verifier.VerifyTable(perspective()) && VerifyField<int16_t>(verifier, VT_TYPE)
				   && VerifyOffset(verifier, VT_NAME) && verifier.Verify(name())
				   && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		CameraT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void	 UnPackTo(CameraT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<Camera> Pack(flatbuffers::FlatBufferBuilder&			_fbb,
												const CameraT*							_o,
												const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct CameraBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_orthographic(flatbuffers::Offset<CameraOrthographic> orthographic)
		{
			fbb_.AddOffset(Camera::VT_ORTHOGRAPHIC, orthographic);
		}
		void add_perspective(flatbuffers::Offset<CameraPerspective> perspective)
		{
			fbb_.AddOffset(Camera::VT_PERSPECTIVE, perspective);
		}
		void add_type(CameraType type)
		{
			fbb_.AddElement<int16_t>(Camera::VT_TYPE, static_cast<int16_t>(type), 0);
		}
		void add_name(flatbuffers::Offset<flatbuffers::String> name)
		{
			fbb_.AddOffset(Camera::VT_NAME, name);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(Camera::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(Camera::VT_EXTRAS, extras);
		}
		CameraBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		CameraBuilder&				operator=(const CameraBuilder&);
		flatbuffers::Offset<Camera> Finish()
		{
			const auto end = fbb_.EndTable(start_, 6);
			auto	   o   = flatbuffers::Offset<Camera>(end);
			return o;
		}
	};

	inline flatbuffers::Offset<Camera> CreateCamera(flatbuffers::FlatBufferBuilder&			_fbb,
													flatbuffers::Offset<CameraOrthographic> orthographic = 0,
													flatbuffers::Offset<CameraPerspective>  perspective  = 0,
													CameraType type = CameraType::perspective,
													flatbuffers::Offset<flatbuffers::String>		  name		 = 0,
													flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions = 0,
													flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras	 = 0)
	{
		CameraBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_name(name);
		builder_.add_perspective(perspective);
		builder_.add_orthographic(orthographic);
		builder_.add_type(type);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<Camera> CreateCameraDirect(flatbuffers::FlatBufferBuilder&		  _fbb,
														  flatbuffers::Offset<CameraOrthographic> orthographic = 0,
														  flatbuffers::Offset<CameraPerspective>  perspective  = 0,
														  CameraType				  type = CameraType::perspective,
														  const char*				  name = nullptr,
														  const std::vector<uint8_t>* extensions = nullptr,
														  const std::vector<uint8_t>* extras	 = nullptr)
	{
		return glTF_2_0::CreateCamera(_fbb,
									  orthographic,
									  perspective,
									  type,
									  name ? _fbb.CreateString(name) : 0,
									  extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
									  extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<Camera> CreateCamera(flatbuffers::FlatBufferBuilder&		 _fbb,
											 const CameraT*							 _o,
											 const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	struct ImageT : public flatbuffers::NativeTable
	{
		typedef Image							 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.ImageT";
		}
		std::string			 uri;
		std::string			 mimeType;
		int32_t				 bufferView;
		std::string			 name;
		std::vector<uint8_t> extensions;
		std::vector<uint8_t> extras;
		ImageT() : bufferView(-1)
		{
		}
	};

	///-- camera.schema.json --/
	///----------------------------------------------------------------------------
	///-- image.schema.json
	/// Image
	/// "description": "Image data used to create a texture. Image can be referenced by URI or `bufferView` index.
	/// `mimeType` is required in the latter case."
	struct Image FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef ImageT							 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.Image";
		}
		enum
		{
			VT_URI		  = 4,
			VT_MIMETYPE   = 6,
			VT_BUFFERVIEW = 8,
			VT_NAME		  = 10,
			VT_EXTENSIONS = 12,
			VT_EXTRAS	 = 14
		};
		/// "description": "The uri of the image."
		/// "gltf_detailedDescription": "The uri of the image.  Relative paths are relative to the .gltf file.  Instead
		/// of referencing an external file, the uri can also be a data-uri.  The image format must be jpg or png."
		/// "gltf_uriType": "image"
		/// "format": "uriref"
		const flatbuffers::String* uri() const
		{
			return GetPointer<const flatbuffers::String*>(VT_URI);
		}
		flatbuffers::String* mutable_uri()
		{
			return GetPointer<flatbuffers::String*>(VT_URI);
		}
		/// "description": "The image's MIME type."
		/// NOTE: JsonSchema states enum { "image/jpeg" "image/png" }, but this type of variables are not possible with
		/// flatbuffers, hence keeping the mimeType as string
		const flatbuffers::String* mimeType() const
		{
			return GetPointer<const flatbuffers::String*>(VT_MIMETYPE);
		}
		flatbuffers::String* mutable_mimeType()
		{
			return GetPointer<flatbuffers::String*>(VT_MIMETYPE);
		}
		/// "description": "The index of the bufferView that contains the image. Use this instead of the image's uri
		/// property."
		int32_t bufferView() const
		{
			return GetField<int32_t>(VT_BUFFERVIEW, -1);
		}
		bool mutate_bufferView(int32_t _bufferView)
		{
			return SetField<int32_t>(VT_BUFFERVIEW, _bufferView, -1);
		}
		///-- glTFChildOfRootProperty
		/// The user-defined name of this object.
		/// gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an
		/// accessor and a buffer could have the same name, or two accessors could even have the same name.
		const flatbuffers::String* name() const
		{
			return GetPointer<const flatbuffers::String*>(VT_NAME);
		}
		flatbuffers::String* mutable_name()
		{
			return GetPointer<flatbuffers::String*>(VT_NAME);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_URI) && verifier.Verify(uri())
				   && VerifyOffset(verifier, VT_MIMETYPE) && verifier.Verify(mimeType())
				   && VerifyField<int32_t>(verifier, VT_BUFFERVIEW) && VerifyOffset(verifier, VT_NAME)
				   && verifier.Verify(name()) && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		ImageT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void	UnPackTo(ImageT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<Image> Pack(flatbuffers::FlatBufferBuilder&		   _fbb,
											   const ImageT*						   _o,
											   const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct ImageBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_uri(flatbuffers::Offset<flatbuffers::String> uri)
		{
			fbb_.AddOffset(Image::VT_URI, uri);
		}
		void add_mimeType(flatbuffers::Offset<flatbuffers::String> mimeType)
		{
			fbb_.AddOffset(Image::VT_MIMETYPE, mimeType);
		}
		void add_bufferView(int32_t bufferView)
		{
			fbb_.AddElement<int32_t>(Image::VT_BUFFERVIEW, bufferView, -1);
		}
		void add_name(flatbuffers::Offset<flatbuffers::String> name)
		{
			fbb_.AddOffset(Image::VT_NAME, name);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(Image::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(Image::VT_EXTRAS, extras);
		}
		ImageBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		ImageBuilder&			   operator=(const ImageBuilder&);
		flatbuffers::Offset<Image> Finish()
		{
			const auto end = fbb_.EndTable(start_, 6);
			auto	   o   = flatbuffers::Offset<Image>(end);
			return o;
		}
	};

	inline flatbuffers::Offset<Image> CreateImage(flatbuffers::FlatBufferBuilder&					_fbb,
												  flatbuffers::Offset<flatbuffers::String>			uri		   = 0,
												  flatbuffers::Offset<flatbuffers::String>			mimeType   = 0,
												  int32_t											bufferView = -1,
												  flatbuffers::Offset<flatbuffers::String>			name	   = 0,
												  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions = 0,
												  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras	 = 0)
	{
		ImageBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_name(name);
		builder_.add_bufferView(bufferView);
		builder_.add_mimeType(mimeType);
		builder_.add_uri(uri);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<Image> CreateImageDirect(flatbuffers::FlatBufferBuilder& _fbb,
														const char*						uri		   = nullptr,
														const char*						mimeType   = nullptr,
														int32_t							bufferView = -1,
														const char*						name	   = nullptr,
														const std::vector<uint8_t>*		extensions = nullptr,
														const std::vector<uint8_t>*		extras	 = nullptr)
	{
		return glTF_2_0::CreateImage(_fbb,
									 uri ? _fbb.CreateString(uri) : 0,
									 mimeType ? _fbb.CreateString(mimeType) : 0,
									 bufferView,
									 name ? _fbb.CreateString(name) : 0,
									 extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
									 extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<Image> CreateImage(flatbuffers::FlatBufferBuilder&		   _fbb,
										   const ImageT*						   _o,
										   const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	struct TextureInfoT : public flatbuffers::NativeTable
	{
		typedef TextureInfo						 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.TextureInfoT";
		}
		int32_t				 index;
		int32_t				 texCoord;
		std::vector<uint8_t> extensions;
		std::vector<uint8_t> extras;
		TextureInfoT() : index(-1), texCoord(0)
		{
		}
	};

	///-- image.schema.json --/
	///----------------------------------------------------------------------------
	///-- textureInfo.schema.json
	/// Texture Info
	/// "description": "Reference to a texture."
	struct TextureInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef TextureInfoT					 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.TextureInfo";
		}
		enum
		{
			VT_INDEX	  = 4,
			VT_TEXCOORD   = 6,
			VT_EXTENSIONS = 8,
			VT_EXTRAS	 = 10
		};
		/// "description": "The index of the texture."
		int32_t index() const
		{
			return GetField<int32_t>(VT_INDEX, -1);
		}
		bool mutate_index(int32_t _index)
		{
			return SetField<int32_t>(VT_INDEX, _index, -1);
		}
		/// "description": "The set index of texture's TEXCOORD attribute used for texture coordinate mapping."
		/// "gltf_detailedDescription": "This integer value is used to construct a string in the format TEXCOORD_<set
		/// index> which is a reference to a key in mesh.primitives.attributes (e.g. A value of 0 corresponds to
		/// TEXCOORD_0)."
		int32_t texCoord() const
		{
			return GetField<int32_t>(VT_TEXCOORD, 0);
		}
		bool mutate_texCoord(int32_t _texCoord)
		{
			return SetField<int32_t>(VT_TEXCOORD, _texCoord, 0);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_INDEX)
				   && VerifyField<int32_t>(verifier, VT_TEXCOORD) && VerifyOffset(verifier, VT_EXTENSIONS)
				   && verifier.Verify(extensions()) && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras())
				   && verifier.EndTable();
		}
		TextureInfoT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void		  UnPackTo(TextureInfoT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<TextureInfo> Pack(flatbuffers::FlatBufferBuilder&		 _fbb,
													 const TextureInfoT*					 _o,
													 const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct TextureInfoBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_index(int32_t index)
		{
			fbb_.AddElement<int32_t>(TextureInfo::VT_INDEX, index, -1);
		}
		void add_texCoord(int32_t texCoord)
		{
			fbb_.AddElement<int32_t>(TextureInfo::VT_TEXCOORD, texCoord, 0);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(TextureInfo::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(TextureInfo::VT_EXTRAS, extras);
		}
		TextureInfoBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		TextureInfoBuilder&				 operator=(const TextureInfoBuilder&);
		flatbuffers::Offset<TextureInfo> Finish()
		{
			const auto end = fbb_.EndTable(start_, 4);
			auto	   o   = flatbuffers::Offset<TextureInfo>(end);
			return o;
		}
	};

	inline flatbuffers::Offset<TextureInfo> CreateTextureInfo(flatbuffers::FlatBufferBuilder& _fbb,
															  int32_t						  index	= -1,
															  int32_t						  texCoord = 0,
															  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions = 0,
															  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras = 0)
	{
		TextureInfoBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_texCoord(texCoord);
		builder_.add_index(index);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<TextureInfo> CreateTextureInfoDirect(flatbuffers::FlatBufferBuilder& _fbb,
																	int32_t							index	= -1,
																	int32_t							texCoord = 0,
																	const std::vector<uint8_t>* extensions   = nullptr,
																	const std::vector<uint8_t>* extras		 = nullptr)
	{
		return glTF_2_0::CreateTextureInfo(_fbb,
										   index,
										   texCoord,
										   extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
										   extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<TextureInfo> CreateTextureInfo(flatbuffers::FlatBufferBuilder&		   _fbb,
													   const TextureInfoT*					   _o,
													   const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	struct MaterialNormalTextureInfoT : public flatbuffers::NativeTable
	{
		typedef MaterialNormalTextureInfo		 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.MaterialNormalTextureInfoT";
		}
		float				 scale;
		int32_t				 index;
		int32_t				 texCoord;
		std::vector<uint8_t> extensions;
		std::vector<uint8_t> extras;
		MaterialNormalTextureInfoT() : scale(1.0f), index(-1), texCoord(0)
		{
		}
	};

	///-- textureInfo.schema.json --/
	///----------------------------------------------------------------------------
	///-- material.normalTextureInfo.schema.json
	/// Material Normal Texture Info
	struct MaterialNormalTextureInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef MaterialNormalTextureInfoT		 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.MaterialNormalTextureInfo";
		}
		enum
		{
			VT_SCALE	  = 4,
			VT_INDEX	  = 6,
			VT_TEXCOORD   = 8,
			VT_EXTENSIONS = 10,
			VT_EXTRAS	 = 12
		};
		/// "description": "The scalar multiplier applied to each normal vector of the normal texture."
		/// "gltf_detailedDescription": "The scalar multiplier applied to each normal vector of the texture. This value
		/// scales the normal vector using the formula: `scaledNormal =  normalize((normalize(<sampled normal texture
		/// value>) * 2.0 - 1.0) * vec3(<normal scale>, <normal scale>, 1.0))`. This value is ignored if normalTexture
		/// is not specified. This value is linear."
		float scale() const
		{
			return GetField<float>(VT_SCALE, 1.0f);
		}
		bool mutate_scale(float _scale)
		{
			return SetField<float>(VT_SCALE, _scale, 1.0f);
		}
		///-- TextureInfo
		/// "description": "The index of the texture."
		int32_t index() const
		{
			return GetField<int32_t>(VT_INDEX, -1);
		}
		bool mutate_index(int32_t _index)
		{
			return SetField<int32_t>(VT_INDEX, _index, -1);
		}
		/// "description": "The set index of texture's TEXCOORD attribute used for texture coordinate mapping."
		/// "gltf_detailedDescription": "This integer value is used to construct a string in the format TEXCOORD_<set
		/// index> which is a reference to a key in mesh.primitives.attributes (e.g. A value of 0 corresponds to
		/// TEXCOORD_0)."
		int32_t texCoord() const
		{
			return GetField<int32_t>(VT_TEXCOORD, 0);
		}
		bool mutate_texCoord(int32_t _texCoord)
		{
			return SetField<int32_t>(VT_TEXCOORD, _texCoord, 0);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_SCALE)
				   && VerifyField<int32_t>(verifier, VT_INDEX) && VerifyField<int32_t>(verifier, VT_TEXCOORD)
				   && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		MaterialNormalTextureInfoT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void UnPackTo(MaterialNormalTextureInfoT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<MaterialNormalTextureInfo> Pack(flatbuffers::FlatBufferBuilder&   _fbb,
																   const MaterialNormalTextureInfoT* _o,
																   const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct MaterialNormalTextureInfoBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_scale(float scale)
		{
			fbb_.AddElement<float>(MaterialNormalTextureInfo::VT_SCALE, scale, 1.0f);
		}
		void add_index(int32_t index)
		{
			fbb_.AddElement<int32_t>(MaterialNormalTextureInfo::VT_INDEX, index, -1);
		}
		void add_texCoord(int32_t texCoord)
		{
			fbb_.AddElement<int32_t>(MaterialNormalTextureInfo::VT_TEXCOORD, texCoord, 0);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(MaterialNormalTextureInfo::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(MaterialNormalTextureInfo::VT_EXTRAS, extras);
		}
		MaterialNormalTextureInfoBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		MaterialNormalTextureInfoBuilder&			   operator=(const MaterialNormalTextureInfoBuilder&);
		flatbuffers::Offset<MaterialNormalTextureInfo> Finish()
		{
			const auto end = fbb_.EndTable(start_, 5);
			auto	   o   = flatbuffers::Offset<MaterialNormalTextureInfo>(end);
			return o;
		}
	};

	inline flatbuffers::Offset<MaterialNormalTextureInfo>
	CreateMaterialNormalTextureInfo(flatbuffers::FlatBufferBuilder&					  _fbb,
									float											  scale		 = 1.0f,
									int32_t											  index		 = -1,
									int32_t											  texCoord   = 0,
									flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions = 0,
									flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras	 = 0)
	{
		MaterialNormalTextureInfoBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_texCoord(texCoord);
		builder_.add_index(index);
		builder_.add_scale(scale);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<MaterialNormalTextureInfo>
	CreateMaterialNormalTextureInfoDirect(flatbuffers::FlatBufferBuilder& _fbb,
										  float							  scale		 = 1.0f,
										  int32_t						  index		 = -1,
										  int32_t						  texCoord   = 0,
										  const std::vector<uint8_t>*	 extensions = nullptr,
										  const std::vector<uint8_t>*	 extras	 = nullptr)
	{
		return glTF_2_0::CreateMaterialNormalTextureInfo(_fbb,
														 scale,
														 index,
														 texCoord,
														 extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
														 extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<MaterialNormalTextureInfo> CreateMaterialNormalTextureInfo(flatbuffers::FlatBufferBuilder& _fbb,
																				   const MaterialNormalTextureInfoT* _o,
																				   const flatbuffers::rehasher_function_t* _rehasher
																				   = nullptr);

	struct MaterialOcclusionTextureInfoT : public flatbuffers::NativeTable
	{
		typedef MaterialOcclusionTextureInfo	 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.MaterialOcclusionTextureInfoT";
		}
		float				 strength;
		int32_t				 index;
		int32_t				 texCoord;
		std::vector<uint8_t> extensions;
		std::vector<uint8_t> extras;
		MaterialOcclusionTextureInfoT() : strength(1.0f), index(-1), texCoord(0)
		{
		}
	};

	///-- material.normalTextureInfo.schema.json --/
	///-- material.occlusionTextureInfo.schema.json
	/// Material Occlusion Texture Info
	struct MaterialOcclusionTextureInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef MaterialOcclusionTextureInfoT	NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.MaterialOcclusionTextureInfo";
		}
		enum
		{
			VT_STRENGTH   = 4,
			VT_INDEX	  = 6,
			VT_TEXCOORD   = 8,
			VT_EXTENSIONS = 10,
			VT_EXTRAS	 = 12
		};
		/// "description": "A scalar multiplier controlling the amount of occlusion applied."
		/// "gltf_detailedDescription": "A scalar multiplier controlling the amount of occlusion applied. A value of 0.0
		/// means no occlusion. A value of 1.0 means full occlusion. This value affects the resulting color using the
		/// formula: `occludedColor = lerp(color, color * <sampled occlusion texture value>, <occlusion strength>)`.
		/// This value is ignored if the corresponding texture is not specified. This value is linear.
		float strength() const
		{
			return GetField<float>(VT_STRENGTH, 1.0f);
		}
		bool mutate_strength(float _strength)
		{
			return SetField<float>(VT_STRENGTH, _strength, 1.0f);
		}
		///-- TextureInfo
		/// "description": "The index of the texture."
		int32_t index() const
		{
			return GetField<int32_t>(VT_INDEX, -1);
		}
		bool mutate_index(int32_t _index)
		{
			return SetField<int32_t>(VT_INDEX, _index, -1);
		}
		/// "description": "The set index of texture's TEXCOORD attribute used for texture coordinate mapping."
		/// "gltf_detailedDescription": "This integer value is used to construct a string in the format TEXCOORD_<set
		/// index> which is a reference to a key in mesh.primitives.attributes (e.g. A value of 0 corresponds to
		/// TEXCOORD_0)."
		int32_t texCoord() const
		{
			return GetField<int32_t>(VT_TEXCOORD, 0);
		}
		bool mutate_texCoord(int32_t _texCoord)
		{
			return SetField<int32_t>(VT_TEXCOORD, _texCoord, 0);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_STRENGTH)
				   && VerifyField<int32_t>(verifier, VT_INDEX) && VerifyField<int32_t>(verifier, VT_TEXCOORD)
				   && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		MaterialOcclusionTextureInfoT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void UnPackTo(MaterialOcclusionTextureInfoT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<MaterialOcclusionTextureInfo> Pack(flatbuffers::FlatBufferBuilder&	  _fbb,
																	  const MaterialOcclusionTextureInfoT* _o,
																	  const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct MaterialOcclusionTextureInfoBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_strength(float strength)
		{
			fbb_.AddElement<float>(MaterialOcclusionTextureInfo::VT_STRENGTH, strength, 1.0f);
		}
		void add_index(int32_t index)
		{
			fbb_.AddElement<int32_t>(MaterialOcclusionTextureInfo::VT_INDEX, index, -1);
		}
		void add_texCoord(int32_t texCoord)
		{
			fbb_.AddElement<int32_t>(MaterialOcclusionTextureInfo::VT_TEXCOORD, texCoord, 0);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(MaterialOcclusionTextureInfo::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(MaterialOcclusionTextureInfo::VT_EXTRAS, extras);
		}
		MaterialOcclusionTextureInfoBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		MaterialOcclusionTextureInfoBuilder&			  operator=(const MaterialOcclusionTextureInfoBuilder&);
		flatbuffers::Offset<MaterialOcclusionTextureInfo> Finish()
		{
			const auto end = fbb_.EndTable(start_, 5);
			auto	   o   = flatbuffers::Offset<MaterialOcclusionTextureInfo>(end);
			return o;
		}
	};

	inline flatbuffers::Offset<MaterialOcclusionTextureInfo>
	CreateMaterialOcclusionTextureInfo(flatbuffers::FlatBufferBuilder&					 _fbb,
									   float											 strength   = 1.0f,
									   int32_t											 index		= -1,
									   int32_t											 texCoord   = 0,
									   flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions = 0,
									   flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras		= 0)
	{
		MaterialOcclusionTextureInfoBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_texCoord(texCoord);
		builder_.add_index(index);
		builder_.add_strength(strength);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<MaterialOcclusionTextureInfo>
	CreateMaterialOcclusionTextureInfoDirect(flatbuffers::FlatBufferBuilder& _fbb,
											 float							 strength   = 1.0f,
											 int32_t						 index		= -1,
											 int32_t						 texCoord   = 0,
											 const std::vector<uint8_t>*	 extensions = nullptr,
											 const std::vector<uint8_t>*	 extras		= nullptr)
	{
		return glTF_2_0::CreateMaterialOcclusionTextureInfo(_fbb,
															strength,
															index,
															texCoord,
															extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
															extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<MaterialOcclusionTextureInfo> CreateMaterialOcclusionTextureInfo(flatbuffers::FlatBufferBuilder& _fbb,
																						 const MaterialOcclusionTextureInfoT* _o,
																						 const flatbuffers::rehasher_function_t* _rehasher
																						 = nullptr);

	struct MaterialPbrMetallicRoughnessT : public flatbuffers::NativeTable
	{
		typedef MaterialPbrMetallicRoughness	 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.MaterialPbrMetallicRoughnessT";
		}
		std::vector<float>			  baseColorFactor;
		std::unique_ptr<TextureInfoT> baseColorTexture;
		float						  metallicFactor;
		float						  roughnessFactor;
		std::unique_ptr<TextureInfoT> metallicRoughnessTexture;
		std::vector<uint8_t>		  extensions;
		std::vector<uint8_t>		  extras;
		MaterialPbrMetallicRoughnessT() : metallicFactor(1.0f), roughnessFactor(1.0f)
		{
		}
	};

	///-- material.occlusionTextureInfo.schema.json --/
	///-- material.pbrMetallicRoughness.schema.json
	/// Material PBR Metallic Roughness
	/// "description": "A set of parameter values that are used to define the metallic-roughness material model from
	/// Physically-Based Rendering (PBR) methodology."
	struct MaterialPbrMetallicRoughness FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef MaterialPbrMetallicRoughnessT	NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.MaterialPbrMetallicRoughness";
		}
		enum
		{
			VT_BASECOLORFACTOR			= 4,
			VT_BASECOLORTEXTURE			= 6,
			VT_METALLICFACTOR			= 8,
			VT_ROUGHNESSFACTOR			= 10,
			VT_METALLICROUGHNESSTEXTURE = 12,
			VT_EXTENSIONS				= 14,
			VT_EXTRAS					= 16
		};
		/// "description": "The material's base color factor."
		/// "gltf_detailedDescription": "The RGBA components of the base color of the material. The fourth component (A)
		/// is the alpha coverage of the material. The `alphaMode` property specifies how alpha is interpreted. These
		/// values are linear. If a baseColorTexture is specified, this value is multiplied with the texel values."
		/// "minItems": 4
		/// "maxItems": 4
		/// "default": [ 1.0, 1.0, 1.0, 1.0 ]
		const flatbuffers::Vector<float>* baseColorFactor() const
		{
			return GetPointer<const flatbuffers::Vector<float>*>(VT_BASECOLORFACTOR);
		}
		flatbuffers::Vector<float>* mutable_baseColorFactor()
		{
			return GetPointer<flatbuffers::Vector<float>*>(VT_BASECOLORFACTOR);
		}
		/// "description": "The base color texture."
		/// "gltf_detailedDescription": "The base color texture. This texture contains RGB(A) components in sRGB color
		/// space. The first three components (RGB) specify the base color of the material. If the fourth component (A)
		/// is present, it represents the alpha coverage of the material. Otherwise, an alpha of 1.0 is assumed. The
		/// `alphaMode` property specifies how alpha is interpreted. The stored texels must not be premultiplied."
		const TextureInfo* baseColorTexture() const
		{
			return GetPointer<const TextureInfo*>(VT_BASECOLORTEXTURE);
		}
		TextureInfo* mutable_baseColorTexture()
		{
			return GetPointer<TextureInfo*>(VT_BASECOLORTEXTURE);
		}
		/// "description": "The metalness of the material."
		/// "gltf_detailedDescription": "The metalness of the material. A value of 1.0 means the material is a metal. A
		/// value of 0.0 means the material is a dielectric. Values in between are for blending between metals and
		/// dielectrics such as dirty metallic surfaces. This value is linear. If a metallicRoughnessTexture is
		/// specified, this value is multiplied with the metallic texel values."
		float metallicFactor() const
		{
			return GetField<float>(VT_METALLICFACTOR, 1.0f);
		}
		bool mutate_metallicFactor(float _metallicFactor)
		{
			return SetField<float>(VT_METALLICFACTOR, _metallicFactor, 1.0f);
		}
		/// "description": "The roughness of the material."
		/// "gltf_detailedDescription": "The roughness of the material. A value of 1.0 means the material is completely
		/// rough. A value of 0.0 means the material is completely smooth. This value is linear. If a
		/// metallicRoughnessTexture is specified, this value is multiplied with the roughness texel values." "minimum":
		/// 0.0 "maximum": 1.0 "default": 1.0
		float roughnessFactor() const
		{
			return GetField<float>(VT_ROUGHNESSFACTOR, 1.0f);
		}
		bool mutate_roughnessFactor(float _roughnessFactor)
		{
			return SetField<float>(VT_ROUGHNESSFACTOR, _roughnessFactor, 1.0f);
		}
		/// "description": "The metallic-roughness texture."
		/// "gltf_detailedDescription": "The metallic-roughness texture. The metalness values are sampled from the B
		/// channel. The roughness values are sampled from the G channel. These values are linear. If other channels are
		/// present (R or A), they are ignored for metallic-roughness calculations."
		const TextureInfo* metallicRoughnessTexture() const
		{
			return GetPointer<const TextureInfo*>(VT_METALLICROUGHNESSTEXTURE);
		}
		TextureInfo* mutable_metallicRoughnessTexture()
		{
			return GetPointer<TextureInfo*>(VT_METALLICROUGHNESSTEXTURE);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_BASECOLORFACTOR)
				   && verifier.Verify(baseColorFactor()) && VerifyOffset(verifier, VT_BASECOLORTEXTURE)
				   && verifier.VerifyTable(baseColorTexture()) && VerifyField<float>(verifier, VT_METALLICFACTOR)
				   && VerifyField<float>(verifier, VT_ROUGHNESSFACTOR) && VerifyOffset(verifier, VT_METALLICROUGHNESSTEXTURE)
				   && verifier.VerifyTable(metallicRoughnessTexture()) && VerifyOffset(verifier, VT_EXTENSIONS)
				   && verifier.Verify(extensions()) && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras())
				   && verifier.EndTable();
		}
		MaterialPbrMetallicRoughnessT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void UnPackTo(MaterialPbrMetallicRoughnessT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<MaterialPbrMetallicRoughness> Pack(flatbuffers::FlatBufferBuilder&	  _fbb,
																	  const MaterialPbrMetallicRoughnessT* _o,
																	  const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct MaterialPbrMetallicRoughnessBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void add_baseColorFactor(flatbuffers::Offset<flatbuffers::Vector<float>> baseColorFactor)
		{
			fbb_.AddOffset(MaterialPbrMetallicRoughness::VT_BASECOLORFACTOR, baseColorFactor);
		}
		void add_baseColorTexture(flatbuffers::Offset<TextureInfo> baseColorTexture)
		{
			fbb_.AddOffset(MaterialPbrMetallicRoughness::VT_BASECOLORTEXTURE, baseColorTexture);
		}
		void add_metallicFactor(float metallicFactor)
		{
			fbb_.AddElement<float>(MaterialPbrMetallicRoughness::VT_METALLICFACTOR, metallicFactor, 1.0f);
		}
		void add_roughnessFactor(float roughnessFactor)
		{
			fbb_.AddElement<float>(MaterialPbrMetallicRoughness::VT_ROUGHNESSFACTOR, roughnessFactor, 1.0f);
		}
		void add_metallicRoughnessTexture(flatbuffers::Offset<TextureInfo> metallicRoughnessTexture)
		{
			fbb_.AddOffset(MaterialPbrMetallicRoughness::VT_METALLICROUGHNESSTEXTURE, metallicRoughnessTexture);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(MaterialPbrMetallicRoughness::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(MaterialPbrMetallicRoughness::VT_EXTRAS, extras);
		}
		MaterialPbrMetallicRoughnessBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		MaterialPbrMetallicRoughnessBuilder&			  operator=(const MaterialPbrMetallicRoughnessBuilder&);
		flatbuffers::Offset<MaterialPbrMetallicRoughness> Finish()
		{
			const auto end = fbb_.EndTable(start_, 7);
			auto	   o   = flatbuffers::Offset<MaterialPbrMetallicRoughness>(end);
			return o;
		}
	};

	inline flatbuffers::Offset<MaterialPbrMetallicRoughness>
	CreateMaterialPbrMetallicRoughness(flatbuffers::FlatBufferBuilder&					 _fbb,
									   flatbuffers::Offset<flatbuffers::Vector<float>>   baseColorFactor  = 0,
									   flatbuffers::Offset<TextureInfo>					 baseColorTexture = 0,
									   float											 metallicFactor   = 1.0f,
									   float											 roughnessFactor  = 1.0f,
									   flatbuffers::Offset<TextureInfo>					 metallicRoughnessTexture = 0,
									   flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions				  = 0,
									   flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras					  = 0)
	{
		MaterialPbrMetallicRoughnessBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_metallicRoughnessTexture(metallicRoughnessTexture);
		builder_.add_roughnessFactor(roughnessFactor);
		builder_.add_metallicFactor(metallicFactor);
		builder_.add_baseColorTexture(baseColorTexture);
		builder_.add_baseColorFactor(baseColorFactor);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<MaterialPbrMetallicRoughness>
	CreateMaterialPbrMetallicRoughnessDirect(flatbuffers::FlatBufferBuilder&  _fbb,
											 const std::vector<float>*		  baseColorFactor		   = nullptr,
											 flatbuffers::Offset<TextureInfo> baseColorTexture		   = 0,
											 float							  metallicFactor		   = 1.0f,
											 float							  roughnessFactor		   = 1.0f,
											 flatbuffers::Offset<TextureInfo> metallicRoughnessTexture = 0,
											 const std::vector<uint8_t>*	  extensions			   = nullptr,
											 const std::vector<uint8_t>*	  extras				   = nullptr)
	{
		return glTF_2_0::CreateMaterialPbrMetallicRoughness(_fbb,
															baseColorFactor ? _fbb.CreateVector<float>(*baseColorFactor) : 0,
															baseColorTexture,
															metallicFactor,
															roughnessFactor,
															metallicRoughnessTexture,
															extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
															extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<MaterialPbrMetallicRoughness> CreateMaterialPbrMetallicRoughness(flatbuffers::FlatBufferBuilder& _fbb,
																						 const MaterialPbrMetallicRoughnessT* _o,
																						 const flatbuffers::rehasher_function_t* _rehasher
																						 = nullptr);

	struct MaterialT : public flatbuffers::NativeTable
	{
		typedef Material						 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.MaterialT";
		}
		std::unique_ptr<MaterialPbrMetallicRoughnessT> pbrMetallicRoughness;
		std::unique_ptr<MaterialNormalTextureInfoT>	normalTexture;
		std::unique_ptr<MaterialOcclusionTextureInfoT> occlusionTexture;
		std::unique_ptr<TextureInfoT>				   emissiveTexture;
		std::vector<float>							   emissiveFactor;
		MaterialAlphaMode							   alphaMode;
		float										   alphaCutoff;
		bool										   doubleSided;
		std::string									   name;
		std::vector<uint8_t>						   extensions;
		std::vector<uint8_t>						   extras;
		MaterialT() : alphaMode(MaterialAlphaMode::OPAQUE), alphaCutoff(0.5f), doubleSided(false)
		{
		}
	};

	/// Material
	/// "description": "The material appearance of a primitive."
	struct Material FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef MaterialT						 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.Material";
		}
		enum
		{
			VT_PBRMETALLICROUGHNESS = 4,
			VT_NORMALTEXTURE		= 6,
			VT_OCCLUSIONTEXTURE		= 8,
			VT_EMISSIVETEXTURE		= 10,
			VT_EMISSIVEFACTOR		= 12,
			VT_ALPHAMODE			= 14,
			VT_ALPHACUTOFF			= 16,
			VT_DOUBLESIDED			= 18,
			VT_NAME					= 20,
			VT_EXTENSIONS			= 22,
			VT_EXTRAS				= 24
		};
		/// "description": "A set of parameter values that are used to define the metallic-roughness material model from
		/// Physically-Based Rendering (PBR) methodology. When not specified, all the default values of
		/// `pbrMetallicRoughness` apply."
		const MaterialPbrMetallicRoughness* pbrMetallicRoughness() const
		{
			return GetPointer<const MaterialPbrMetallicRoughness*>(VT_PBRMETALLICROUGHNESS);
		}
		MaterialPbrMetallicRoughness* mutable_pbrMetallicRoughness()
		{
			return GetPointer<MaterialPbrMetallicRoughness*>(VT_PBRMETALLICROUGHNESS);
		}
		/// "description": "The normal map texture."
		/// "gltf_detailedDescription": "A tangent space normal map. The texture contains RGB components in linear
		/// space. Each texel represents the XYZ components of a normal vector in tangent space. Red [0 to 255] maps to
		/// X [-1 to 1]. Green [0 to 255] maps to Y [-1 to 1]. Blue [128 to 255] maps to Z [1/255 to 1]. The normal
		/// vectors use OpenGL conventions where +X is right and +Y is up. +Z points toward the viewer. In GLSL, this
		/// vector would be unpacked like so: `float3 normalVector = tex2D(<sampled normal map texture value>, texCoord)
		/// * 2 - 1`."
		const MaterialNormalTextureInfo* normalTexture() const
		{
			return GetPointer<const MaterialNormalTextureInfo*>(VT_NORMALTEXTURE);
		}
		MaterialNormalTextureInfo* mutable_normalTexture()
		{
			return GetPointer<MaterialNormalTextureInfo*>(VT_NORMALTEXTURE);
		}
		/// "description": "The occlusion map texture."
		/// "gltf_detailedDescription": "The occlusion map texture. The occlusion values are sampled from the R channel.
		/// Higher values indicate areas that should receive full indirect lighting and lower values indicate no
		/// indirect lighting. These values are linear. If other channels are present (GBA), they are ignored for
		/// occlusion calculations."
		const MaterialOcclusionTextureInfo* occlusionTexture() const
		{
			return GetPointer<const MaterialOcclusionTextureInfo*>(VT_OCCLUSIONTEXTURE);
		}
		MaterialOcclusionTextureInfo* mutable_occlusionTexture()
		{
			return GetPointer<MaterialOcclusionTextureInfo*>(VT_OCCLUSIONTEXTURE);
		}
		/// "description": "The emissive map texture."
		/// "gltf_detailedDescription": "The emissive map controls the color and intensity of the light being emitted by
		/// the material. This texture contains RGB components in sRGB color space. If a fourth component (A) is
		/// present, it is ignored."
		const TextureInfo* emissiveTexture() const
		{
			return GetPointer<const TextureInfo*>(VT_EMISSIVETEXTURE);
		}
		TextureInfo* mutable_emissiveTexture()
		{
			return GetPointer<TextureInfo*>(VT_EMISSIVETEXTURE);
		}
		/// "description": "The emissive color of the material."
		/// "gltf_detailedDescription": "The RGB components of the emissive color of the material. These values are
		/// linear. If an emissiveTexture is specified, this value is multiplied with the texel values." "minItems": 3,
		/// "maxItems": 3,
		/// "default": [ 0.0, 0.0, 0.0 ],
		const flatbuffers::Vector<float>* emissiveFactor() const
		{
			return GetPointer<const flatbuffers::Vector<float>*>(VT_EMISSIVEFACTOR);
		}
		flatbuffers::Vector<float>* mutable_emissiveFactor()
		{
			return GetPointer<flatbuffers::Vector<float>*>(VT_EMISSIVEFACTOR);
		}
		/// "description": "The alpha rendering mode of the material."
		/// "gltf_detailedDescription": "The material's alpha rendering mode enumeration specifying the interpretation
		/// of the alpha value of the main factor and texture."
		MaterialAlphaMode alphaMode() const
		{
			return static_cast<MaterialAlphaMode>(GetField<int16_t>(VT_ALPHAMODE, 0));
		}
		bool mutate_alphaMode(MaterialAlphaMode _alphaMode)
		{
			return SetField<int16_t>(VT_ALPHAMODE, static_cast<int16_t>(_alphaMode), 0);
		}
		/// "description": "The alpha cutoff value of the material."
		/// "gltf_detailedDescription": "Specifies the cutoff threshold when in `MASK` mode. If the alpha value is
		/// greater than or equal to this value then it is rendered as fully opaque, otherwise, it is rendered as fully
		/// transparent. A value greater than 1.0 will render the entire material as fully transparent. This value is
		/// ignored for other modes."
		float alphaCutoff() const
		{
			return GetField<float>(VT_ALPHACUTOFF, 0.5f);
		}
		bool mutate_alphaCutoff(float _alphaCutoff)
		{
			return SetField<float>(VT_ALPHACUTOFF, _alphaCutoff, 0.5f);
		}
		/// "description": "Specifies whether the material is double sided."
		/// "gltf_detailedDescription": "Specifies whether the material is double sided. When this value is false,
		/// back-face culling is enabled. When this value is true, back-face culling is disabled and double sided
		/// lighting is enabled. The back-face must have its normals reversed before the lighting equation is
		/// evaluated."
		bool doubleSided() const
		{
			return GetField<uint8_t>(VT_DOUBLESIDED, 0) != 0;
		}
		bool mutate_doubleSided(bool _doubleSided)
		{
			return SetField<uint8_t>(VT_DOUBLESIDED, static_cast<uint8_t>(_doubleSided), 0);
		}
		///-- glTFChildOfRootProperty
		/// The user-defined name of this object.
		/// gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an
		/// accessor and a buffer could have the same name, or two accessors could even have the same name.
		const flatbuffers::String* name() const
		{
			return GetPointer<const flatbuffers::String*>(VT_NAME);
		}
		flatbuffers::String* mutable_name()
		{
			return GetPointer<flatbuffers::String*>(VT_NAME);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_PBRMETALLICROUGHNESS)
				   && verifier.VerifyTable(pbrMetallicRoughness()) && VerifyOffset(verifier, VT_NORMALTEXTURE)
				   && verifier.VerifyTable(normalTexture()) && VerifyOffset(verifier, VT_OCCLUSIONTEXTURE)
				   && verifier.VerifyTable(occlusionTexture()) && VerifyOffset(verifier, VT_EMISSIVETEXTURE)
				   && verifier.VerifyTable(emissiveTexture()) && VerifyOffset(verifier, VT_EMISSIVEFACTOR)
				   && verifier.Verify(emissiveFactor()) && VerifyField<int16_t>(verifier, VT_ALPHAMODE)
				   && VerifyField<float>(verifier, VT_ALPHACUTOFF) && VerifyField<uint8_t>(verifier, VT_DOUBLESIDED)
				   && VerifyOffset(verifier, VT_NAME) && verifier.Verify(name())
				   && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		MaterialT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void	   UnPackTo(MaterialT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<Material> Pack(flatbuffers::FlatBufferBuilder&		  _fbb,
												  const MaterialT*						  _o,
												  const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct MaterialBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void add_pbrMetallicRoughness(flatbuffers::Offset<MaterialPbrMetallicRoughness> pbrMetallicRoughness)
		{
			fbb_.AddOffset(Material::VT_PBRMETALLICROUGHNESS, pbrMetallicRoughness);
		}
		void add_normalTexture(flatbuffers::Offset<MaterialNormalTextureInfo> normalTexture)
		{
			fbb_.AddOffset(Material::VT_NORMALTEXTURE, normalTexture);
		}
		void add_occlusionTexture(flatbuffers::Offset<MaterialOcclusionTextureInfo> occlusionTexture)
		{
			fbb_.AddOffset(Material::VT_OCCLUSIONTEXTURE, occlusionTexture);
		}
		void add_emissiveTexture(flatbuffers::Offset<TextureInfo> emissiveTexture)
		{
			fbb_.AddOffset(Material::VT_EMISSIVETEXTURE, emissiveTexture);
		}
		void add_emissiveFactor(flatbuffers::Offset<flatbuffers::Vector<float>> emissiveFactor)
		{
			fbb_.AddOffset(Material::VT_EMISSIVEFACTOR, emissiveFactor);
		}
		void add_alphaMode(MaterialAlphaMode alphaMode)
		{
			fbb_.AddElement<int16_t>(Material::VT_ALPHAMODE, static_cast<int16_t>(alphaMode), 0);
		}
		void add_alphaCutoff(float alphaCutoff)
		{
			fbb_.AddElement<float>(Material::VT_ALPHACUTOFF, alphaCutoff, 0.5f);
		}
		void add_doubleSided(bool doubleSided)
		{
			fbb_.AddElement<uint8_t>(Material::VT_DOUBLESIDED, static_cast<uint8_t>(doubleSided), 0);
		}
		void add_name(flatbuffers::Offset<flatbuffers::String> name)
		{
			fbb_.AddOffset(Material::VT_NAME, name);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(Material::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(Material::VT_EXTRAS, extras);
		}
		MaterialBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		MaterialBuilder&			  operator=(const MaterialBuilder&);
		flatbuffers::Offset<Material> Finish()
		{
			const auto end = fbb_.EndTable(start_, 11);
			auto	   o   = flatbuffers::Offset<Material>(end);
			return o;
		}
	};

	inline flatbuffers::Offset<Material> CreateMaterial(flatbuffers::FlatBufferBuilder&					  _fbb,
														flatbuffers::Offset<MaterialPbrMetallicRoughness> pbrMetallicRoughness = 0,
														flatbuffers::Offset<MaterialNormalTextureInfo> normalTexture = 0,
														flatbuffers::Offset<MaterialOcclusionTextureInfo> occlusionTexture = 0,
														flatbuffers::Offset<TextureInfo> emissiveTexture = 0,
														flatbuffers::Offset<flatbuffers::Vector<float>> emissiveFactor = 0,
														MaterialAlphaMode alphaMode   = MaterialAlphaMode::OPAQUE,
														float			  alphaCutoff = 0.5f,
														bool			  doubleSided = false,
														flatbuffers::Offset<flatbuffers::String>		  name = 0,
														flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions = 0,
														flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras = 0)
	{
		MaterialBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_name(name);
		builder_.add_alphaCutoff(alphaCutoff);
		builder_.add_emissiveFactor(emissiveFactor);
		builder_.add_emissiveTexture(emissiveTexture);
		builder_.add_occlusionTexture(occlusionTexture);
		builder_.add_normalTexture(normalTexture);
		builder_.add_pbrMetallicRoughness(pbrMetallicRoughness);
		builder_.add_alphaMode(alphaMode);
		builder_.add_doubleSided(doubleSided);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<Material> CreateMaterialDirect(flatbuffers::FlatBufferBuilder&					_fbb,
															  flatbuffers::Offset<MaterialPbrMetallicRoughness> pbrMetallicRoughness = 0,
															  flatbuffers::Offset<MaterialNormalTextureInfo> normalTexture = 0,
															  flatbuffers::Offset<MaterialOcclusionTextureInfo> occlusionTexture = 0,
															  flatbuffers::Offset<TextureInfo> emissiveTexture = 0,
															  const std::vector<float>*		   emissiveFactor = nullptr,
															  MaterialAlphaMode alphaMode   = MaterialAlphaMode::OPAQUE,
															  float				alphaCutoff = 0.5f,
															  bool				doubleSided = false,
															  const char*		name		= nullptr,
															  const std::vector<uint8_t>* extensions = nullptr,
															  const std::vector<uint8_t>* extras	 = nullptr)
	{
		return glTF_2_0::CreateMaterial(_fbb,
										pbrMetallicRoughness,
										normalTexture,
										occlusionTexture,
										emissiveTexture,
										emissiveFactor ? _fbb.CreateVector<float>(*emissiveFactor) : 0,
										alphaMode,
										alphaCutoff,
										doubleSided,
										name ? _fbb.CreateString(name) : 0,
										extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
										extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<Material> CreateMaterial(flatbuffers::FlatBufferBuilder&		 _fbb,
												 const MaterialT*						 _o,
												 const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	struct MeshPrimitiveAttributeT : public flatbuffers::NativeTable
	{
		typedef MeshPrimitiveAttribute			 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.MeshPrimitiveAttributeT";
		}
		std::string id;
		int32_t		value;
		MeshPrimitiveAttributeT() : value(-1)
		{
		}
	};

	struct MeshPrimitiveAttribute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef MeshPrimitiveAttributeT			 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.MeshPrimitiveAttribute";
		}
		enum
		{
			VT_ID	= 4,
			VT_VALUE = 6
		};
		const flatbuffers::String* id() const
		{
			return GetPointer<const flatbuffers::String*>(VT_ID);
		}
		flatbuffers::String* mutable_id()
		{
			return GetPointer<flatbuffers::String*>(VT_ID);
		}
		bool KeyCompareLessThan(const MeshPrimitiveAttribute* o) const
		{
			return *id() < *o->id();
		}
		int KeyCompareWithValue(const char* val) const
		{
			return strcmp(id()->c_str(), val);
		}
		int32_t value() const
		{
			return GetField<int32_t>(VT_VALUE, -1);
		}
		bool mutate_value(int32_t _value)
		{
			return SetField<int32_t>(VT_VALUE, _value, -1);
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_ID) && verifier.Verify(id())
				   && VerifyField<int32_t>(verifier, VT_VALUE) && verifier.EndTable();
		}
		MeshPrimitiveAttributeT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void UnPackTo(MeshPrimitiveAttributeT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<MeshPrimitiveAttribute> Pack(flatbuffers::FlatBufferBuilder&			_fbb,
																const MeshPrimitiveAttributeT*			_o,
																const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct MeshPrimitiveAttributeBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_id(flatbuffers::Offset<flatbuffers::String> id)
		{
			fbb_.AddOffset(MeshPrimitiveAttribute::VT_ID, id);
		}
		void add_value(int32_t value)
		{
			fbb_.AddElement<int32_t>(MeshPrimitiveAttribute::VT_VALUE, value, -1);
		}
		MeshPrimitiveAttributeBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		MeshPrimitiveAttributeBuilder&				operator=(const MeshPrimitiveAttributeBuilder&);
		flatbuffers::Offset<MeshPrimitiveAttribute> Finish()
		{
			const auto end = fbb_.EndTable(start_, 2);
			auto	   o   = flatbuffers::Offset<MeshPrimitiveAttribute>(end);
			fbb_.Required(o, MeshPrimitiveAttribute::VT_ID);
			return o;
		}
	};

	inline flatbuffers::Offset<MeshPrimitiveAttribute> CreateMeshPrimitiveAttribute(flatbuffers::FlatBufferBuilder& _fbb,
																					flatbuffers::Offset<flatbuffers::String> id = 0,
																					int32_t value = -1)
	{
		MeshPrimitiveAttributeBuilder builder_(_fbb);
		builder_.add_value(value);
		builder_.add_id(id);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<MeshPrimitiveAttribute> CreateMeshPrimitiveAttributeDirect(flatbuffers::FlatBufferBuilder& _fbb,
																						  const char* id	= nullptr,
																						  int32_t	 value = -1)
	{
		return glTF_2_0::CreateMeshPrimitiveAttribute(_fbb, id ? _fbb.CreateString(id) : 0, value);
	}

	flatbuffers::Offset<MeshPrimitiveAttribute> CreateMeshPrimitiveAttribute(flatbuffers::FlatBufferBuilder& _fbb,
																			 const MeshPrimitiveAttributeT*  _o,
																			 const flatbuffers::rehasher_function_t* _rehasher
																			 = nullptr);

	struct MeshPrimitiveT : public flatbuffers::NativeTable
	{
		typedef MeshPrimitive					 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.MeshPrimitiveT";
		}
		std::vector<uint8_t> attributes;
		int32_t				 indices;
		int32_t				 material;
		MeshPrimitiveMode	mode;
		std::vector<uint8_t> targets;
		std::vector<uint8_t> extensions;
		std::vector<uint8_t> extras;
		MeshPrimitiveT() : indices(-1), material(-1), mode(MeshPrimitiveMode::TRIANGLES)
		{
		}
	};

	/// Mesh Primitive
	/// "description": "Geometry to be rendered with the given material."
	/// "gltf_webgl": "`drawElements()` and `drawArrays()`"
	struct MeshPrimitive FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef MeshPrimitiveT					 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.MeshPrimitive";
		}
		enum
		{
			VT_ATTRIBUTES = 4,
			VT_INDICES	= 6,
			VT_MATERIAL   = 8,
			VT_MODE		  = 10,
			VT_TARGETS	= 12,
			VT_EXTENSIONS = 14,
			VT_EXTRAS	 = 16
		};
		/// "description": "A dictionary object, where each key corresponds to mesh attribute semantic and each value is
		/// the index of the accessor containing attribute's data."
		///! NOTE: dictionary objects are not possible with flatbuffers (yet), hence this workaround
		const flatbuffers::Vector<uint8_t>* attributes() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_ATTRIBUTES);
		}
		flatbuffers::Vector<uint8_t>* mutable_attributes()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_ATTRIBUTES);
		}
		flexbuffers::Reference attributes_flexbuffer_root() const
		{
			auto v = attributes();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// "description": "The index of the accessor that contains the indices."
		/// "gltf_detailedDescription": "The index of the accessor that contains mesh indices.  When this is not
		/// defined, the primitives should be rendered without indices using `drawArrays()`.  When defined, the accessor
		/// must contain indices: the `bufferView` referenced by the accessor should have a `target` equal to 34963
		/// (ELEMENT_ARRAY_BUFFER); `componentType` must be 5121 (UNSIGNED_BYTE), 5123 (UNSIGNED_SHORT) or 5125
		/// (UNSIGNED_INT), the latter may require enabling additional hardware support; `type` must be `\"SCALAR\"`.
		/// For triangle primitives, the front face has a counter-clockwise (CCW) winding order."
		int32_t indices() const
		{
			return GetField<int32_t>(VT_INDICES, -1);
		}
		bool mutate_indices(int32_t _indices)
		{
			return SetField<int32_t>(VT_INDICES, _indices, -1);
		}
		/// "description": "The index of the material to apply to this primitive when rendering."
		int32_t material() const
		{
			return GetField<int32_t>(VT_MATERIAL, -1);
		}
		bool mutate_material(int32_t _material)
		{
			return SetField<int32_t>(VT_MATERIAL, _material, -1);
		}
		/// "description": "The type of primitives to render."
		/// "gltf_detailedDescription": "The type of primitives to render. All valid values correspond to WebGL enums."
		MeshPrimitiveMode mode() const
		{
			return static_cast<MeshPrimitiveMode>(GetField<uint8_t>(VT_MODE, 4));
		}
		bool mutate_mode(MeshPrimitiveMode _mode)
		{
			return SetField<uint8_t>(VT_MODE, static_cast<uint8_t>(_mode), 4);
		}
		/// "description": "An array of Morph Targets, each  Morph Target is a dictionary mapping attributes (only
		/// `POSITION`, `NORMAL`, and `TANGENT` supported) to their deviations in the Morph Target." "description": "A
		/// dictionary object specifying attributes displacements in a Morph Target, where each key corresponds to one
		/// of the three supported attribute semantic (`POSITION`, `NORMAL`, or `TANGENT`) and each value is the index
		/// of the accessor containing the attribute displacements' data."
		const flatbuffers::Vector<uint8_t>* targets() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_TARGETS);
		}
		flatbuffers::Vector<uint8_t>* mutable_targets()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_TARGETS);
		}
		flexbuffers::Reference targets_flexbuffer_root() const
		{
			auto v = targets();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_ATTRIBUTES) && verifier.Verify(attributes())
				   && VerifyField<int32_t>(verifier, VT_INDICES) && VerifyField<int32_t>(verifier, VT_MATERIAL)
				   && VerifyField<uint8_t>(verifier, VT_MODE) && VerifyOffset(verifier, VT_TARGETS)
				   && verifier.Verify(targets()) && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		MeshPrimitiveT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void			UnPackTo(MeshPrimitiveT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<MeshPrimitive> Pack(flatbuffers::FlatBufferBuilder&		   _fbb,
													   const MeshPrimitiveT*				   _o,
													   const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct MeshPrimitiveBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_attributes(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> attributes)
		{
			fbb_.AddOffset(MeshPrimitive::VT_ATTRIBUTES, attributes);
		}
		void add_indices(int32_t indices)
		{
			fbb_.AddElement<int32_t>(MeshPrimitive::VT_INDICES, indices, -1);
		}
		void add_material(int32_t material)
		{
			fbb_.AddElement<int32_t>(MeshPrimitive::VT_MATERIAL, material, -1);
		}
		void add_mode(MeshPrimitiveMode mode)
		{
			fbb_.AddElement<uint8_t>(MeshPrimitive::VT_MODE, static_cast<uint8_t>(mode), 4);
		}
		void add_targets(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> targets)
		{
			fbb_.AddOffset(MeshPrimitive::VT_TARGETS, targets);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(MeshPrimitive::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(MeshPrimitive::VT_EXTRAS, extras);
		}
		MeshPrimitiveBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		MeshPrimitiveBuilder&			   operator=(const MeshPrimitiveBuilder&);
		flatbuffers::Offset<MeshPrimitive> Finish()
		{
			const auto end = fbb_.EndTable(start_, 7);
			auto	   o   = flatbuffers::Offset<MeshPrimitive>(end);
			fbb_.Required(o, MeshPrimitive::VT_ATTRIBUTES);
			return o;
		}
	};

	inline flatbuffers::Offset<MeshPrimitive> CreateMeshPrimitive(flatbuffers::FlatBufferBuilder& _fbb,
																  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> attributes = 0,
																  int32_t			indices  = -1,
																  int32_t			material = -1,
																  MeshPrimitiveMode mode = MeshPrimitiveMode::TRIANGLES,
																  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> targets = 0,
																  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions = 0,
																  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras = 0)
	{
		MeshPrimitiveBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_targets(targets);
		builder_.add_material(material);
		builder_.add_indices(indices);
		builder_.add_attributes(attributes);
		builder_.add_mode(mode);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<MeshPrimitive> CreateMeshPrimitiveDirect(flatbuffers::FlatBufferBuilder& _fbb,
																		const std::vector<uint8_t>* attributes = nullptr,
																		int32_t						indices	= -1,
																		int32_t						material   = -1,
																		MeshPrimitiveMode mode = MeshPrimitiveMode::TRIANGLES,
																		const std::vector<uint8_t>* targets = nullptr,
																		const std::vector<uint8_t>* extensions = nullptr,
																		const std::vector<uint8_t>* extras = nullptr)
	{
		return glTF_2_0::CreateMeshPrimitive(_fbb,
											 attributes ? _fbb.CreateVector<uint8_t>(*attributes) : 0,
											 indices,
											 material,
											 mode,
											 targets ? _fbb.CreateVector<uint8_t>(*targets) : 0,
											 extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
											 extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<MeshPrimitive> CreateMeshPrimitive(flatbuffers::FlatBufferBuilder&		   _fbb,
														   const MeshPrimitiveT*				   _o,
														   const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	struct MeshT : public flatbuffers::NativeTable
	{
		typedef Mesh							 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.MeshT";
		}
		std::vector<std::unique_ptr<MeshPrimitiveT>> primitives;
		std::vector<float>							 weights;
		std::string									 name;
		std::vector<uint8_t>						 extensions;
		std::vector<uint8_t>						 extras;
		MeshT()
		{
		}
	};

	///-- mesh.primitive.schema.json --/
	///-- mesh.schema.json
	/// Mesh
	/// "description": "A set of primitives to be rendered.  A node can contain one mesh.  A node's transform places the
	/// mesh in the scene."
	struct Mesh FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef MeshT							 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.Mesh";
		}
		enum
		{
			VT_PRIMITIVES = 4,
			VT_WEIGHTS	= 6,
			VT_NAME		  = 8,
			VT_EXTENSIONS = 10,
			VT_EXTRAS	 = 12
		};
		/// "description": "An array of primitives, each defining geometry to be rendered with a material."
		const flatbuffers::Vector<flatbuffers::Offset<MeshPrimitive>>* primitives() const
		{
			return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MeshPrimitive>>*>(VT_PRIMITIVES);
		}
		flatbuffers::Vector<flatbuffers::Offset<MeshPrimitive>>* mutable_primitives()
		{
			return GetPointer<flatbuffers::Vector<flatbuffers::Offset<MeshPrimitive>>*>(VT_PRIMITIVES);
		}
		/// "description": "Array of weights to be applied to the Morph Targets."
		const flatbuffers::Vector<float>* weights() const
		{
			return GetPointer<const flatbuffers::Vector<float>*>(VT_WEIGHTS);
		}
		flatbuffers::Vector<float>* mutable_weights()
		{
			return GetPointer<flatbuffers::Vector<float>*>(VT_WEIGHTS);
		}
		///-- glTFChildOfRootProperty
		/// The user-defined name of this object.
		/// gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an
		/// accessor and a buffer could have the same name, or two accessors could even have the same name.
		const flatbuffers::String* name() const
		{
			return GetPointer<const flatbuffers::String*>(VT_NAME);
		}
		flatbuffers::String* mutable_name()
		{
			return GetPointer<flatbuffers::String*>(VT_NAME);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_PRIMITIVES)
				   && verifier.Verify(primitives()) && verifier.VerifyVectorOfTables(primitives())
				   && VerifyOffset(verifier, VT_WEIGHTS) && verifier.Verify(weights()) && VerifyOffset(verifier, VT_NAME)
				   && verifier.Verify(name()) && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		MeshT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void   UnPackTo(MeshT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<Mesh> Pack(flatbuffers::FlatBufferBuilder&		  _fbb,
											  const MeshT*							  _o,
											  const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct MeshBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void add_primitives(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MeshPrimitive>>> primitives)
		{
			fbb_.AddOffset(Mesh::VT_PRIMITIVES, primitives);
		}
		void add_weights(flatbuffers::Offset<flatbuffers::Vector<float>> weights)
		{
			fbb_.AddOffset(Mesh::VT_WEIGHTS, weights);
		}
		void add_name(flatbuffers::Offset<flatbuffers::String> name)
		{
			fbb_.AddOffset(Mesh::VT_NAME, name);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(Mesh::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(Mesh::VT_EXTRAS, extras);
		}
		MeshBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		MeshBuilder&			  operator=(const MeshBuilder&);
		flatbuffers::Offset<Mesh> Finish()
		{
			const auto end = fbb_.EndTable(start_, 5);
			auto	   o   = flatbuffers::Offset<Mesh>(end);
			fbb_.Required(o, Mesh::VT_PRIMITIVES);
			return o;
		}
	};

	inline flatbuffers::Offset<Mesh> CreateMesh(flatbuffers::FlatBufferBuilder& _fbb,
												flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MeshPrimitive>>> primitives = 0,
												flatbuffers::Offset<flatbuffers::Vector<float>>   weights	= 0,
												flatbuffers::Offset<flatbuffers::String>		  name		 = 0,
												flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions = 0,
												flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras	 = 0)
	{
		MeshBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_name(name);
		builder_.add_weights(weights);
		builder_.add_primitives(primitives);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<Mesh> CreateMeshDirect(flatbuffers::FlatBufferBuilder&						 _fbb,
													  const std::vector<flatbuffers::Offset<MeshPrimitive>>* primitives = nullptr,
													  const std::vector<float>*   weights	= nullptr,
													  const char*				  name		 = nullptr,
													  const std::vector<uint8_t>* extensions = nullptr,
													  const std::vector<uint8_t>* extras	 = nullptr)
	{
		return glTF_2_0::CreateMesh(_fbb,
									primitives ? _fbb.CreateVector<flatbuffers::Offset<MeshPrimitive>>(*primitives) : 0,
									weights ? _fbb.CreateVector<float>(*weights) : 0,
									name ? _fbb.CreateString(name) : 0,
									extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
									extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<Mesh> CreateMesh(flatbuffers::FlatBufferBuilder&		 _fbb,
										 const MeshT*							 _o,
										 const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	struct NodeT : public flatbuffers::NativeTable
	{
		typedef Node							 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.NodeT";
		}
		int32_t				 camera;
		std::vector<int32_t> children;
		int32_t				 skin;
		std::vector<float>   matrix;
		int32_t				 mesh;
		std::vector<float>   rotation;
		std::vector<float>   scale;
		std::vector<float>   translation;
		std::vector<float>   weights;
		std::string			 name;
		std::vector<uint8_t> extensions;
		std::vector<uint8_t> extras;
		NodeT() : camera(-1), skin(-1), mesh(-1)
		{
		}
	};

	///-- mesh.schema.json --/
	///----------------------------------------------------------------------------
	///-- node.schema.json
	/// Node
	/// "description": "A node in the node hierarchy.  When the node contains `skin`, all `mesh.primitives` must contain
	/// `JOINTS_0` and `WEIGHTS_0` attributes.  A node can have either a `matrix` or any combination of
	/// `translation`/`rotation`/`scale` (TRS) properties. TRS properties are converted to matrices and postmultiplied
	/// in the `T * R * S` order to compose the transformation matrix; first the scale is applied to the vertices, then
	/// the rotation, and then the translation. If none are provided, the transform is the identity. When a node is
	/// targeted for animation (referenced by an animation.channel.target), only TRS properties may be present; `matrix`
	/// will not be present."
	struct Node FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef NodeT							 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.Node";
		}
		enum
		{
			VT_CAMERA	  = 4,
			VT_CHILDREN	= 6,
			VT_SKIN		   = 8,
			VT_MATRIX	  = 10,
			VT_MESH		   = 12,
			VT_ROTATION	= 14,
			VT_SCALE	   = 16,
			VT_TRANSLATION = 18,
			VT_WEIGHTS	 = 20,
			VT_NAME		   = 22,
			VT_EXTENSIONS  = 24,
			VT_EXTRAS	  = 26
		};
		/// "description": "The index of the camera referenced by this node."
		int32_t camera() const
		{
			return GetField<int32_t>(VT_CAMERA, -1);
		}
		bool mutate_camera(int32_t _camera)
		{
			return SetField<int32_t>(VT_CAMERA, _camera, -1);
		}
		/// "description": "The indices of this node's children."
		const flatbuffers::Vector<int32_t>* children() const
		{
			return GetPointer<const flatbuffers::Vector<int32_t>*>(VT_CHILDREN);
		}
		flatbuffers::Vector<int32_t>* mutable_children()
		{
			return GetPointer<flatbuffers::Vector<int32_t>*>(VT_CHILDREN);
		}
		/// "description": "The index of the skin referenced by this node."
		int32_t skin() const
		{
			return GetField<int32_t>(VT_SKIN, -1);
		}
		bool mutate_skin(int32_t _skin)
		{
			return SetField<int32_t>(VT_SKIN, _skin, -1);
		}
		/// "description": "A floating-point 4x4 transformation matrix stored in column-major order."
		/// "gltf_detailedDescription": "A floating-point 4x4 transformation matrix stored in column-major order."
		/// "gltf_webgl": "`uniformMatrix4fv()` with the transpose parameter equal to false"
		/// "minItems": 16
		/// "maxItems": 16
		/// "default": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
		const flatbuffers::Vector<float>* matrix() const
		{
			return GetPointer<const flatbuffers::Vector<float>*>(VT_MATRIX);
		}
		flatbuffers::Vector<float>* mutable_matrix()
		{
			return GetPointer<flatbuffers::Vector<float>*>(VT_MATRIX);
		}
		/// "description": "The index of the mesh in this node."
		int32_t mesh() const
		{
			return GetField<int32_t>(VT_MESH, -1);
		}
		bool mutate_mesh(int32_t _mesh)
		{
			return SetField<int32_t>(VT_MESH, _mesh, -1);
		}
		/// "description": "The node's unit quaternion rotation in the order (x, y, z, w), where w is the scalar."
		/// "minimum": -1.0
		/// "maximum": 1.0
		/// "minItems": 4
		/// "maxItems": 4
		/// "default": [ 0.0, 0.0, 0.0, 1.0 ]
		const flatbuffers::Vector<float>* rotation() const
		{
			return GetPointer<const flatbuffers::Vector<float>*>(VT_ROTATION);
		}
		flatbuffers::Vector<float>* mutable_rotation()
		{
			return GetPointer<flatbuffers::Vector<float>*>(VT_ROTATION);
		}
		/// "description": "The node's non-uniform scale."
		/// "minItems": 3
		/// "maxItems": 3
		/// "default": [ 1.0, 1.0, 1.0 ]
		const flatbuffers::Vector<float>* scale() const
		{
			return GetPointer<const flatbuffers::Vector<float>*>(VT_SCALE);
		}
		flatbuffers::Vector<float>* mutable_scale()
		{
			return GetPointer<flatbuffers::Vector<float>*>(VT_SCALE);
		}
		/// "description": "The node's translation."
		/// "minItems": 3
		/// "maxItems": 3
		/// "default": [ 0.0, 0.0, 0.0 ]
		const flatbuffers::Vector<float>* translation() const
		{
			return GetPointer<const flatbuffers::Vector<float>*>(VT_TRANSLATION);
		}
		flatbuffers::Vector<float>* mutable_translation()
		{
			return GetPointer<flatbuffers::Vector<float>*>(VT_TRANSLATION);
		}
		/// "description": "The weights of the instantiated Morph Target. Number of elements must match number of Morph
		/// Targets of used mesh." "minItems": 1
		const flatbuffers::Vector<float>* weights() const
		{
			return GetPointer<const flatbuffers::Vector<float>*>(VT_WEIGHTS);
		}
		flatbuffers::Vector<float>* mutable_weights()
		{
			return GetPointer<flatbuffers::Vector<float>*>(VT_WEIGHTS);
		}
		///-- glTFChildOfRootProperty
		/// The user-defined name of this object.
		/// gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an
		/// accessor and a buffer could have the same name, or two accessors could even have the same name.
		const flatbuffers::String* name() const
		{
			return GetPointer<const flatbuffers::String*>(VT_NAME);
		}
		flatbuffers::String* mutable_name()
		{
			return GetPointer<flatbuffers::String*>(VT_NAME);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_CAMERA)
				   && VerifyOffset(verifier, VT_CHILDREN) && verifier.Verify(children())
				   && VerifyField<int32_t>(verifier, VT_SKIN) && VerifyOffset(verifier, VT_MATRIX)
				   && verifier.Verify(matrix()) && VerifyField<int32_t>(verifier, VT_MESH)
				   && VerifyOffset(verifier, VT_ROTATION) && verifier.Verify(rotation()) && VerifyOffset(verifier, VT_SCALE)
				   && verifier.Verify(scale()) && VerifyOffset(verifier, VT_TRANSLATION) && verifier.Verify(translation())
				   && VerifyOffset(verifier, VT_WEIGHTS) && verifier.Verify(weights()) && VerifyOffset(verifier, VT_NAME)
				   && verifier.Verify(name()) && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		NodeT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void   UnPackTo(NodeT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<Node> Pack(flatbuffers::FlatBufferBuilder&		  _fbb,
											  const NodeT*							  _o,
											  const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct NodeBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_camera(int32_t camera)
		{
			fbb_.AddElement<int32_t>(Node::VT_CAMERA, camera, -1);
		}
		void add_children(flatbuffers::Offset<flatbuffers::Vector<int32_t>> children)
		{
			fbb_.AddOffset(Node::VT_CHILDREN, children);
		}
		void add_skin(int32_t skin)
		{
			fbb_.AddElement<int32_t>(Node::VT_SKIN, skin, -1);
		}
		void add_matrix(flatbuffers::Offset<flatbuffers::Vector<float>> matrix)
		{
			fbb_.AddOffset(Node::VT_MATRIX, matrix);
		}
		void add_mesh(int32_t mesh)
		{
			fbb_.AddElement<int32_t>(Node::VT_MESH, mesh, -1);
		}
		void add_rotation(flatbuffers::Offset<flatbuffers::Vector<float>> rotation)
		{
			fbb_.AddOffset(Node::VT_ROTATION, rotation);
		}
		void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale)
		{
			fbb_.AddOffset(Node::VT_SCALE, scale);
		}
		void add_translation(flatbuffers::Offset<flatbuffers::Vector<float>> translation)
		{
			fbb_.AddOffset(Node::VT_TRANSLATION, translation);
		}
		void add_weights(flatbuffers::Offset<flatbuffers::Vector<float>> weights)
		{
			fbb_.AddOffset(Node::VT_WEIGHTS, weights);
		}
		void add_name(flatbuffers::Offset<flatbuffers::String> name)
		{
			fbb_.AddOffset(Node::VT_NAME, name);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(Node::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(Node::VT_EXTRAS, extras);
		}
		NodeBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		NodeBuilder&			  operator=(const NodeBuilder&);
		flatbuffers::Offset<Node> Finish()
		{
			const auto end = fbb_.EndTable(start_, 12);
			auto	   o   = flatbuffers::Offset<Node>(end);
			return o;
		}
	};

	inline flatbuffers::Offset<Node> CreateNode(flatbuffers::FlatBufferBuilder&					  _fbb,
												int32_t											  camera	  = -1,
												flatbuffers::Offset<flatbuffers::Vector<int32_t>> children	= 0,
												int32_t											  skin		  = -1,
												flatbuffers::Offset<flatbuffers::Vector<float>>   matrix	  = 0,
												int32_t											  mesh		  = -1,
												flatbuffers::Offset<flatbuffers::Vector<float>>   rotation	= 0,
												flatbuffers::Offset<flatbuffers::Vector<float>>   scale		  = 0,
												flatbuffers::Offset<flatbuffers::Vector<float>>   translation = 0,
												flatbuffers::Offset<flatbuffers::Vector<float>>   weights	 = 0,
												flatbuffers::Offset<flatbuffers::String>		  name		  = 0,
												flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions  = 0,
												flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras	  = 0)
	{
		NodeBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_name(name);
		builder_.add_weights(weights);
		builder_.add_translation(translation);
		builder_.add_scale(scale);
		builder_.add_rotation(rotation);
		builder_.add_mesh(mesh);
		builder_.add_matrix(matrix);
		builder_.add_skin(skin);
		builder_.add_children(children);
		builder_.add_camera(camera);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<Node> CreateNodeDirect(flatbuffers::FlatBufferBuilder& _fbb,
													  int32_t						  camera	  = -1,
													  const std::vector<int32_t>*	 children	= nullptr,
													  int32_t						  skin		  = -1,
													  const std::vector<float>*		  matrix	  = nullptr,
													  int32_t						  mesh		  = -1,
													  const std::vector<float>*		  rotation	= nullptr,
													  const std::vector<float>*		  scale		  = nullptr,
													  const std::vector<float>*		  translation = nullptr,
													  const std::vector<float>*		  weights	 = nullptr,
													  const char*					  name		  = nullptr,
													  const std::vector<uint8_t>*	 extensions  = nullptr,
													  const std::vector<uint8_t>*	 extras	  = nullptr)
	{
		return glTF_2_0::CreateNode(_fbb,
									camera,
									children ? _fbb.CreateVector<int32_t>(*children) : 0,
									skin,
									matrix ? _fbb.CreateVector<float>(*matrix) : 0,
									mesh,
									rotation ? _fbb.CreateVector<float>(*rotation) : 0,
									scale ? _fbb.CreateVector<float>(*scale) : 0,
									translation ? _fbb.CreateVector<float>(*translation) : 0,
									weights ? _fbb.CreateVector<float>(*weights) : 0,
									name ? _fbb.CreateString(name) : 0,
									extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
									extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<Node> CreateNode(flatbuffers::FlatBufferBuilder&		 _fbb,
										 const NodeT*							 _o,
										 const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	struct SceneT : public flatbuffers::NativeTable
	{
		typedef Scene							 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.SceneT";
		}
		std::vector<int32_t> nodes;
		std::string			 name;
		std::vector<uint8_t> extensions;
		std::vector<uint8_t> extras;
		SceneT()
		{
		}
	};

	///-- node.schema.json --/
	///----------------------------------------------------------------------------
	///-- scene.schema.json
	/// Scene
	/// "description": "The root nodes of a scene."
	struct Scene FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef SceneT							 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.Scene";
		}
		enum
		{
			VT_NODES	  = 4,
			VT_NAME		  = 6,
			VT_EXTENSIONS = 8,
			VT_EXTRAS	 = 10
		};
		/// "description": "The indices of each root node."
		const flatbuffers::Vector<int32_t>* nodes() const
		{
			return GetPointer<const flatbuffers::Vector<int32_t>*>(VT_NODES);
		}
		flatbuffers::Vector<int32_t>* mutable_nodes()
		{
			return GetPointer<flatbuffers::Vector<int32_t>*>(VT_NODES);
		}
		///-- glTFChildOfRootProperty
		/// The user-defined name of this object.
		/// gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an
		/// accessor and a buffer could have the same name, or two accessors could even have the same name.
		const flatbuffers::String* name() const
		{
			return GetPointer<const flatbuffers::String*>(VT_NAME);
		}
		flatbuffers::String* mutable_name()
		{
			return GetPointer<flatbuffers::String*>(VT_NAME);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NODES) && verifier.Verify(nodes())
				   && VerifyOffset(verifier, VT_NAME) && verifier.Verify(name())
				   && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		SceneT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void	UnPackTo(SceneT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<Scene> Pack(flatbuffers::FlatBufferBuilder&		   _fbb,
											   const SceneT*						   _o,
											   const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct SceneBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_nodes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> nodes)
		{
			fbb_.AddOffset(Scene::VT_NODES, nodes);
		}
		void add_name(flatbuffers::Offset<flatbuffers::String> name)
		{
			fbb_.AddOffset(Scene::VT_NAME, name);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(Scene::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(Scene::VT_EXTRAS, extras);
		}
		SceneBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		SceneBuilder&			   operator=(const SceneBuilder&);
		flatbuffers::Offset<Scene> Finish()
		{
			const auto end = fbb_.EndTable(start_, 4);
			auto	   o   = flatbuffers::Offset<Scene>(end);
			return o;
		}
	};

	inline flatbuffers::Offset<Scene> CreateScene(flatbuffers::FlatBufferBuilder&					_fbb,
												  flatbuffers::Offset<flatbuffers::Vector<int32_t>> nodes	  = 0,
												  flatbuffers::Offset<flatbuffers::String>			name	   = 0,
												  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions = 0,
												  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras	 = 0)
	{
		SceneBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_name(name);
		builder_.add_nodes(nodes);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<Scene> CreateSceneDirect(flatbuffers::FlatBufferBuilder& _fbb,
														const std::vector<int32_t>*		nodes	  = nullptr,
														const char*						name	   = nullptr,
														const std::vector<uint8_t>*		extensions = nullptr,
														const std::vector<uint8_t>*		extras	 = nullptr)
	{
		return glTF_2_0::CreateScene(_fbb,
									 nodes ? _fbb.CreateVector<int32_t>(*nodes) : 0,
									 name ? _fbb.CreateString(name) : 0,
									 extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
									 extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<Scene> CreateScene(flatbuffers::FlatBufferBuilder&		   _fbb,
										   const SceneT*						   _o,
										   const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	struct SamplerT : public flatbuffers::NativeTable
	{
		typedef Sampler							 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.SamplerT";
		}
		SamplerFilter		 magFilter;
		SamplerFilter		 minFilter;
		WrapMode			 wrapS;
		WrapMode			 wrapT;
		std::string			 name;
		std::vector<uint8_t> extensions;
		std::vector<uint8_t> extras;
		SamplerT()
			: magFilter(SamplerFilter::NEAREST), minFilter(SamplerFilter::NEAREST), wrapS(WrapMode::REPEAT), wrapT(WrapMode::REPEAT)
		{
		}
	};

	/// Sampler
	/// "description": "Texture sampler properties for filtering and wrapping modes."
	/// "gltf_webgl": "`texParameterf()`"
	struct Sampler FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef SamplerT						 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.Sampler";
		}
		enum
		{
			VT_MAGFILTER  = 4,
			VT_MINFILTER  = 6,
			VT_WRAPS	  = 8,
			VT_WRAPT	  = 10,
			VT_NAME		  = 12,
			VT_EXTENSIONS = 14,
			VT_EXTRAS	 = 16
		};
		/// "description": "Magnification filter."
		/// "gltf_detailedDescription": "Magnification filter.  Valid values correspond to WebGL enums: `9728` (NEAREST)
		/// and `9729` (LINEAR)." "gltf_webgl": "`texParameterf()` with pname equal to TEXTURE_MAG_FILTER"
		SamplerFilter magFilter() const
		{
			return static_cast<SamplerFilter>(GetField<int32_t>(VT_MAGFILTER, 9728));
		}
		bool mutate_magFilter(SamplerFilter _magFilter)
		{
			return SetField<int32_t>(VT_MAGFILTER, static_cast<int32_t>(_magFilter), 9728);
		}
		/// "description": "Minification filter."
		/// "gltf_detailedDescription": "Minification filter.  All valid values correspond to WebGL enums."
		/// "gltf_webgl": "`texParameterf()` with pname equal to TEXTURE_MIN_FILTER"
		SamplerFilter minFilter() const
		{
			return static_cast<SamplerFilter>(GetField<int32_t>(VT_MINFILTER, 9728));
		}
		bool mutate_minFilter(SamplerFilter _minFilter)
		{
			return SetField<int32_t>(VT_MINFILTER, static_cast<int32_t>(_minFilter), 9728);
		}
		/// "description": "s wrapping mode."
		/// "gltf_detailedDescription": "s wrapping mode.  All valid values correspond to WebGL enums."
		/// "gltf_webgl": "`texParameterf()` with pname equal to TEXTURE_WRAP_S"
		WrapMode wrapS() const
		{
			return static_cast<WrapMode>(GetField<int32_t>(VT_WRAPS, 10497));
		}
		bool mutate_wrapS(WrapMode _wrapS)
		{
			return SetField<int32_t>(VT_WRAPS, static_cast<int32_t>(_wrapS), 10497);
		}
		/// "description": "t wrapping mode."
		/// "gltf_detailedDescription": "t wrapping mode.  All valid values correspond to WebGL enums."
		/// "gltf_webgl": "`texParameterf()` with pname equal to TEXTURE_WRAP_T"
		WrapMode wrapT() const
		{
			return static_cast<WrapMode>(GetField<int32_t>(VT_WRAPT, 10497));
		}
		bool mutate_wrapT(WrapMode _wrapT)
		{
			return SetField<int32_t>(VT_WRAPT, static_cast<int32_t>(_wrapT), 10497);
		}
		///-- glTFChildOfRootProperty
		/// The user-defined name of this object.
		/// gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an
		/// accessor and a buffer could have the same name, or two accessors could even have the same name.
		const flatbuffers::String* name() const
		{
			return GetPointer<const flatbuffers::String*>(VT_NAME);
		}
		flatbuffers::String* mutable_name()
		{
			return GetPointer<flatbuffers::String*>(VT_NAME);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_MAGFILTER)
				   && VerifyField<int32_t>(verifier, VT_MINFILTER) && VerifyField<int32_t>(verifier, VT_WRAPS)
				   && VerifyField<int32_t>(verifier, VT_WRAPT) && VerifyOffset(verifier, VT_NAME)
				   && verifier.Verify(name()) && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		SamplerT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void	  UnPackTo(SamplerT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<Sampler> Pack(flatbuffers::FlatBufferBuilder&		 _fbb,
												 const SamplerT*						 _o,
												 const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct SamplerBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_magFilter(SamplerFilter magFilter)
		{
			fbb_.AddElement<int32_t>(Sampler::VT_MAGFILTER, static_cast<int32_t>(magFilter), 9728);
		}
		void add_minFilter(SamplerFilter minFilter)
		{
			fbb_.AddElement<int32_t>(Sampler::VT_MINFILTER, static_cast<int32_t>(minFilter), 9728);
		}
		void add_wrapS(WrapMode wrapS)
		{
			fbb_.AddElement<int32_t>(Sampler::VT_WRAPS, static_cast<int32_t>(wrapS), 10497);
		}
		void add_wrapT(WrapMode wrapT)
		{
			fbb_.AddElement<int32_t>(Sampler::VT_WRAPT, static_cast<int32_t>(wrapT), 10497);
		}
		void add_name(flatbuffers::Offset<flatbuffers::String> name)
		{
			fbb_.AddOffset(Sampler::VT_NAME, name);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(Sampler::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(Sampler::VT_EXTRAS, extras);
		}
		SamplerBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		SamplerBuilder&				 operator=(const SamplerBuilder&);
		flatbuffers::Offset<Sampler> Finish()
		{
			const auto end = fbb_.EndTable(start_, 7);
			auto	   o   = flatbuffers::Offset<Sampler>(end);
			return o;
		}
	};

	inline flatbuffers::Offset<Sampler> CreateSampler(flatbuffers::FlatBufferBuilder& _fbb,
													  SamplerFilter magFilter = SamplerFilter::NEAREST,
													  SamplerFilter minFilter = SamplerFilter::NEAREST,
													  WrapMode		wrapS	 = WrapMode::REPEAT,
													  WrapMode		wrapT	 = WrapMode::REPEAT,
													  flatbuffers::Offset<flatbuffers::String>			name	   = 0,
													  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions = 0,
													  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras	 = 0)
	{
		SamplerBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_name(name);
		builder_.add_wrapT(wrapT);
		builder_.add_wrapS(wrapS);
		builder_.add_minFilter(minFilter);
		builder_.add_magFilter(magFilter);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<Sampler> CreateSamplerDirect(flatbuffers::FlatBufferBuilder& _fbb,
															SamplerFilter magFilter = SamplerFilter::NEAREST,
															SamplerFilter minFilter = SamplerFilter::NEAREST,
															WrapMode	  wrapS		= WrapMode::REPEAT,
															WrapMode	  wrapT		= WrapMode::REPEAT,
															const char*   name		= nullptr,
															const std::vector<uint8_t>* extensions = nullptr,
															const std::vector<uint8_t>* extras	 = nullptr)
	{
		return glTF_2_0::CreateSampler(_fbb,
									   magFilter,
									   minFilter,
									   wrapS,
									   wrapT,
									   name ? _fbb.CreateString(name) : 0,
									   extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
									   extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<Sampler> CreateSampler(flatbuffers::FlatBufferBuilder&		   _fbb,
											   const SamplerT*						   _o,
											   const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	struct TextureT : public flatbuffers::NativeTable
	{
		typedef Texture							 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.TextureT";
		}
		int32_t				 sampler;
		int32_t				 source;
		std::string			 name;
		std::vector<uint8_t> extensions;
		std::vector<uint8_t> extras;
		TextureT() : sampler(-1), source(-1)
		{
		}
	};

	///-- sampler.schema.json --/
	///----------------------------------------------------------------------------
	///-- texture.schema.json
	/// Texture
	/// "description": "A texture and its sampler."
	/// "gltf_webgl": "`createTexture()`, `deleteTexture()`, `bindTexture()`, `texImage2D()`, and `texParameterf()`"
	struct Texture FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef TextureT						 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.Texture";
		}
		enum
		{
			VT_SAMPLER	= 4,
			VT_SOURCE	 = 6,
			VT_NAME		  = 8,
			VT_EXTENSIONS = 10,
			VT_EXTRAS	 = 12
		};
		/// "description": "The index of the sampler used by this texture. When undefined, a sampler with repeat
		/// wrapping and auto filtering should be used."
		int32_t sampler() const
		{
			return GetField<int32_t>(VT_SAMPLER, -1);
		}
		bool mutate_sampler(int32_t _sampler)
		{
			return SetField<int32_t>(VT_SAMPLER, _sampler, -1);
		}
		/// "description": "The index of the image used by this texture."
		int32_t source() const
		{
			return GetField<int32_t>(VT_SOURCE, -1);
		}
		bool mutate_source(int32_t _source)
		{
			return SetField<int32_t>(VT_SOURCE, _source, -1);
		}
		///-- glTFChildOfRootProperty
		/// The user-defined name of this object.
		/// gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an
		/// accessor and a buffer could have the same name, or two accessors could even have the same name.
		const flatbuffers::String* name() const
		{
			return GetPointer<const flatbuffers::String*>(VT_NAME);
		}
		flatbuffers::String* mutable_name()
		{
			return GetPointer<flatbuffers::String*>(VT_NAME);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_SAMPLER)
				   && VerifyField<int32_t>(verifier, VT_SOURCE) && VerifyOffset(verifier, VT_NAME)
				   && verifier.Verify(name()) && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		TextureT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void	  UnPackTo(TextureT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<Texture> Pack(flatbuffers::FlatBufferBuilder&		 _fbb,
												 const TextureT*						 _o,
												 const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct TextureBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_sampler(int32_t sampler)
		{
			fbb_.AddElement<int32_t>(Texture::VT_SAMPLER, sampler, -1);
		}
		void add_source(int32_t source)
		{
			fbb_.AddElement<int32_t>(Texture::VT_SOURCE, source, -1);
		}
		void add_name(flatbuffers::Offset<flatbuffers::String> name)
		{
			fbb_.AddOffset(Texture::VT_NAME, name);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(Texture::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(Texture::VT_EXTRAS, extras);
		}
		TextureBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		TextureBuilder&				 operator=(const TextureBuilder&);
		flatbuffers::Offset<Texture> Finish()
		{
			const auto end = fbb_.EndTable(start_, 5);
			auto	   o   = flatbuffers::Offset<Texture>(end);
			return o;
		}
	};

	inline flatbuffers::Offset<Texture> CreateTexture(flatbuffers::FlatBufferBuilder&					_fbb,
													  int32_t											sampler	= -1,
													  int32_t											source	 = -1,
													  flatbuffers::Offset<flatbuffers::String>			name	   = 0,
													  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions = 0,
													  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras	 = 0)
	{
		TextureBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_name(name);
		builder_.add_source(source);
		builder_.add_sampler(sampler);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<Texture> CreateTextureDirect(flatbuffers::FlatBufferBuilder& _fbb,
															int32_t							sampler	= -1,
															int32_t							source	 = -1,
															const char*						name	   = nullptr,
															const std::vector<uint8_t>*		extensions = nullptr,
															const std::vector<uint8_t>*		extras	 = nullptr)
	{
		return glTF_2_0::CreateTexture(_fbb,
									   sampler,
									   source,
									   name ? _fbb.CreateString(name) : 0,
									   extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
									   extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<Texture> CreateTexture(flatbuffers::FlatBufferBuilder&		   _fbb,
											   const TextureT*						   _o,
											   const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	struct SkinT : public flatbuffers::NativeTable
	{
		typedef Skin							 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.SkinT";
		}
		int32_t				 inverseBindMatrices;
		int32_t				 skeleton;
		std::vector<int32_t> joints;
		std::string			 name;
		std::vector<uint8_t> extensions;
		std::vector<uint8_t> extras;
		SkinT() : inverseBindMatrices(-1), skeleton(-1)
		{
		}
	};

	///-- texture.schema.json --/
	///----------------------------------------------------------------------------
	///-- skin.schema.json
	/// Skin
	/// "description": "Joints and matrices defining a skin."
	struct Skin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef SkinT							 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.Skin";
		}
		enum
		{
			VT_INVERSEBINDMATRICES = 4,
			VT_SKELETON			   = 6,
			VT_JOINTS			   = 8,
			VT_NAME				   = 10,
			VT_EXTENSIONS		   = 12,
			VT_EXTRAS			   = 14
		};
		/// "description": "The index of the accessor containing the floating-point 4x4 inverse-bind matrices.  The
		/// default is that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were
		/// pre-applied."
		int32_t inverseBindMatrices() const
		{
			return GetField<int32_t>(VT_INVERSEBINDMATRICES, -1);
		}
		bool mutate_inverseBindMatrices(int32_t _inverseBindMatrices)
		{
			return SetField<int32_t>(VT_INVERSEBINDMATRICES, _inverseBindMatrices, -1);
		}
		/// "description": "The index of the node used as a skeleton root. When undefined, joints transforms resolve to
		/// scene root."
		int32_t skeleton() const
		{
			return GetField<int32_t>(VT_SKELETON, -1);
		}
		bool mutate_skeleton(int32_t _skeleton)
		{
			return SetField<int32_t>(VT_SKELETON, _skeleton, -1);
		}
		/// "description": "Indices of skeleton nodes, used as joints in this skin."
		/// "gltf_detailedDescription": "Indices of skeleton nodes, used as joints in this skin.  The array length must
		/// be the same as the `count` property of the `inverseBindMatrices` accessor (when defined)."
		const flatbuffers::Vector<int32_t>* joints() const
		{
			return GetPointer<const flatbuffers::Vector<int32_t>*>(VT_JOINTS);
		}
		flatbuffers::Vector<int32_t>* mutable_joints()
		{
			return GetPointer<flatbuffers::Vector<int32_t>*>(VT_JOINTS);
		}
		///-- glTFChildOfRootProperty
		/// The user-defined name of this object.
		/// gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an
		/// accessor and a buffer could have the same name, or two accessors could even have the same name.
		const flatbuffers::String* name() const
		{
			return GetPointer<const flatbuffers::String*>(VT_NAME);
		}
		flatbuffers::String* mutable_name()
		{
			return GetPointer<flatbuffers::String*>(VT_NAME);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_INVERSEBINDMATRICES)
				   && VerifyField<int32_t>(verifier, VT_SKELETON) && VerifyOffsetRequired(verifier, VT_JOINTS)
				   && verifier.Verify(joints()) && VerifyOffset(verifier, VT_NAME) && verifier.Verify(name())
				   && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		SkinT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void   UnPackTo(SkinT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<Skin> Pack(flatbuffers::FlatBufferBuilder&		  _fbb,
											  const SkinT*							  _o,
											  const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct SkinBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void							add_inverseBindMatrices(int32_t inverseBindMatrices)
		{
			fbb_.AddElement<int32_t>(Skin::VT_INVERSEBINDMATRICES, inverseBindMatrices, -1);
		}
		void add_skeleton(int32_t skeleton)
		{
			fbb_.AddElement<int32_t>(Skin::VT_SKELETON, skeleton, -1);
		}
		void add_joints(flatbuffers::Offset<flatbuffers::Vector<int32_t>> joints)
		{
			fbb_.AddOffset(Skin::VT_JOINTS, joints);
		}
		void add_name(flatbuffers::Offset<flatbuffers::String> name)
		{
			fbb_.AddOffset(Skin::VT_NAME, name);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(Skin::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(Skin::VT_EXTRAS, extras);
		}
		SkinBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		SkinBuilder&			  operator=(const SkinBuilder&);
		flatbuffers::Offset<Skin> Finish()
		{
			const auto end = fbb_.EndTable(start_, 6);
			auto	   o   = flatbuffers::Offset<Skin>(end);
			fbb_.Required(o, Skin::VT_JOINTS);
			return o;
		}
	};

	inline flatbuffers::Offset<Skin> CreateSkin(flatbuffers::FlatBufferBuilder& _fbb,
												int32_t							inverseBindMatrices			 = -1,
												int32_t							skeleton					 = -1,
												flatbuffers::Offset<flatbuffers::Vector<int32_t>> joints	 = 0,
												flatbuffers::Offset<flatbuffers::String>		  name		 = 0,
												flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions = 0,
												flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras	 = 0)
	{
		SkinBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_name(name);
		builder_.add_joints(joints);
		builder_.add_skeleton(skeleton);
		builder_.add_inverseBindMatrices(inverseBindMatrices);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<Skin> CreateSkinDirect(flatbuffers::FlatBufferBuilder& _fbb,
													  int32_t						  inverseBindMatrices = -1,
													  int32_t						  skeleton			  = -1,
													  const std::vector<int32_t>*	 joints			  = nullptr,
													  const char*					  name				  = nullptr,
													  const std::vector<uint8_t>*	 extensions		  = nullptr,
													  const std::vector<uint8_t>*	 extras			  = nullptr)
	{
		return glTF_2_0::CreateSkin(_fbb,
									inverseBindMatrices,
									skeleton,
									joints ? _fbb.CreateVector<int32_t>(*joints) : 0,
									name ? _fbb.CreateString(name) : 0,
									extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
									extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<Skin> CreateSkin(flatbuffers::FlatBufferBuilder&		 _fbb,
										 const SkinT*							 _o,
										 const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	struct RootT : public flatbuffers::NativeTable
	{
		typedef Root							 TableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.RootT";
		}
		std::vector<std::string>				  extensionsUsed;
		std::vector<std::string>				  extensionsRequired;
		std::vector<std::unique_ptr<AccessorT>>   accessors;
		std::vector<std::unique_ptr<AnimationT>>  animations;
		std::unique_ptr<AssetT>					  asset;
		std::vector<std::unique_ptr<BufferT>>	 buffers;
		std::vector<std::unique_ptr<BufferViewT>> bufferViews;
		std::vector<std::unique_ptr<CameraT>>	 cameras;
		std::vector<std::unique_ptr<ImageT>>	  images;
		std::vector<std::unique_ptr<MaterialT>>   materials;
		std::vector<std::unique_ptr<MeshT>>		  meshes;
		std::vector<std::unique_ptr<NodeT>>		  nodes;
		std::vector<std::unique_ptr<SamplerT>>	samplers;
		int32_t									  scene;
		std::vector<std::unique_ptr<SceneT>>	  scenes;
		std::vector<std::unique_ptr<SkinT>>		  skins;
		std::vector<std::unique_ptr<TextureT>>	textures;
		std::vector<uint8_t>					  extensions;
		std::vector<uint8_t>					  extras;
		RootT() : scene(-1)
		{
		}
	};

	///-- skin.schema.json --/
	///----------------------------------------------------------------------------
	///-- glTF.schema.json
	/// The root object for a glTF asset.
	struct Root FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
	{
		typedef RootT							 NativeTableType;
		static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
		{
			return "glTF_2_0.Root";
		}
		enum
		{
			VT_EXTENSIONSUSED	 = 4,
			VT_EXTENSIONSREQUIRED = 6,
			VT_ACCESSORS		  = 8,
			VT_ANIMATIONS		  = 10,
			VT_ASSET			  = 12,
			VT_BUFFERS			  = 14,
			VT_BUFFERVIEWS		  = 16,
			VT_CAMERAS			  = 18,
			VT_IMAGES			  = 20,
			VT_MATERIALS		  = 22,
			VT_MESHES			  = 24,
			VT_NODES			  = 26,
			VT_SAMPLERS			  = 28,
			VT_SCENE			  = 30,
			VT_SCENES			  = 32,
			VT_SKINS			  = 34,
			VT_TEXTURES			  = 36,
			VT_EXTENSIONS		  = 38,
			VT_EXTRAS			  = 40
		};
		/// Names of glTF extensions used somewhere in this asset.
		const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>* extensionsUsed() const
		{
			return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>*>(VT_EXTENSIONSUSED);
		}
		flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>* mutable_extensionsUsed()
		{
			return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>*>(VT_EXTENSIONSUSED);
		}
		/// Names of glTF extensions required to properly load this asset.
		const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>* extensionsRequired() const
		{
			return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>*>(VT_EXTENSIONSREQUIRED);
		}
		flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>* mutable_extensionsRequired()
		{
			return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>*>(VT_EXTENSIONSREQUIRED);
		}
		/// An array of accessors.
		/// gltf_detailedDescription: An array of accessors.  An accessor is a typed view into a bufferView.
		const flatbuffers::Vector<flatbuffers::Offset<Accessor>>* accessors() const
		{
			return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Accessor>>*>(VT_ACCESSORS);
		}
		flatbuffers::Vector<flatbuffers::Offset<Accessor>>* mutable_accessors()
		{
			return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Accessor>>*>(VT_ACCESSORS);
		}
		/// An array of keyframe animations.
		const flatbuffers::Vector<flatbuffers::Offset<Animation>>* animations() const
		{
			return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Animation>>*>(VT_ANIMATIONS);
		}
		flatbuffers::Vector<flatbuffers::Offset<Animation>>* mutable_animations()
		{
			return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Animation>>*>(VT_ANIMATIONS);
		}
		/// Metadata about the glTF asset.
		const Asset* asset() const
		{
			return GetPointer<const Asset*>(VT_ASSET);
		}
		Asset* mutable_asset()
		{
			return GetPointer<Asset*>(VT_ASSET);
		}
		/// An array of buffers.
		/// gltf_detailedDescription: An array of buffers.  A buffer points to binary geometry, animation, or skins.
		const flatbuffers::Vector<flatbuffers::Offset<Buffer>>* buffers() const
		{
			return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Buffer>>*>(VT_BUFFERS);
		}
		flatbuffers::Vector<flatbuffers::Offset<Buffer>>* mutable_buffers()
		{
			return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Buffer>>*>(VT_BUFFERS);
		}
		/// An array of bufferViews.
		/// gltf_detailedDescription: An array of bufferViews.  A bufferView is a view into a buffer generally
		/// representing a subset of the buffer.
		const flatbuffers::Vector<flatbuffers::Offset<BufferView>>* bufferViews() const
		{
			return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BufferView>>*>(VT_BUFFERVIEWS);
		}
		flatbuffers::Vector<flatbuffers::Offset<BufferView>>* mutable_bufferViews()
		{
			return GetPointer<flatbuffers::Vector<flatbuffers::Offset<BufferView>>*>(VT_BUFFERVIEWS);
		}
		/// An array of cameras.
		/// gltf_detailedDescription: An array of cameras.  A camera defines a projection matrix.
		const flatbuffers::Vector<flatbuffers::Offset<Camera>>* cameras() const
		{
			return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Camera>>*>(VT_CAMERAS);
		}
		flatbuffers::Vector<flatbuffers::Offset<Camera>>* mutable_cameras()
		{
			return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Camera>>*>(VT_CAMERAS);
		}
		/// An array of images.
		/// gltf_detailedDescription: An array of images.  An image defines data used to create a texture.
		const flatbuffers::Vector<flatbuffers::Offset<Image>>* images() const
		{
			return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Image>>*>(VT_IMAGES);
		}
		flatbuffers::Vector<flatbuffers::Offset<Image>>* mutable_images()
		{
			return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Image>>*>(VT_IMAGES);
		}
		/// An array of materials.
		/// gltf_detailedDescription: An array of materials.  A material defines the appearance of a primitive.
		const flatbuffers::Vector<flatbuffers::Offset<Material>>* materials() const
		{
			return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Material>>*>(VT_MATERIALS);
		}
		flatbuffers::Vector<flatbuffers::Offset<Material>>* mutable_materials()
		{
			return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Material>>*>(VT_MATERIALS);
		}
		/// An array of meshes.
		/// gltf_detailedDescription: An array of meshes.  A mesh is a set of primitives to be rendered.
		const flatbuffers::Vector<flatbuffers::Offset<Mesh>>* meshes() const
		{
			return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Mesh>>*>(VT_MESHES);
		}
		flatbuffers::Vector<flatbuffers::Offset<Mesh>>* mutable_meshes()
		{
			return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Mesh>>*>(VT_MESHES);
		}
		/// An array of nodes.
		const flatbuffers::Vector<flatbuffers::Offset<Node>>* nodes() const
		{
			return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Node>>*>(VT_NODES);
		}
		flatbuffers::Vector<flatbuffers::Offset<Node>>* mutable_nodes()
		{
			return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Node>>*>(VT_NODES);
		}
		/// An array of samplers.
		/// gltf_detailedDescription: An array of samplers.  A sampler contains properties for texture filtering and
		/// wrapping modes.
		const flatbuffers::Vector<flatbuffers::Offset<Sampler>>* samplers() const
		{
			return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Sampler>>*>(VT_SAMPLERS);
		}
		flatbuffers::Vector<flatbuffers::Offset<Sampler>>* mutable_samplers()
		{
			return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Sampler>>*>(VT_SAMPLERS);
		}
		/// The index of the default scene.
		int32_t scene() const
		{
			return GetField<int32_t>(VT_SCENE, -1);
		}
		bool mutate_scene(int32_t _scene)
		{
			return SetField<int32_t>(VT_SCENE, _scene, -1);
		}
		/// An array of scenes.
		const flatbuffers::Vector<flatbuffers::Offset<Scene>>* scenes() const
		{
			return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Scene>>*>(VT_SCENES);
		}
		flatbuffers::Vector<flatbuffers::Offset<Scene>>* mutable_scenes()
		{
			return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Scene>>*>(VT_SCENES);
		}
		/// An array of skins.
		/// gltf_detailedDescription: An array of skins.  A skin is defined by joints and matrices.
		const flatbuffers::Vector<flatbuffers::Offset<Skin>>* skins() const
		{
			return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Skin>>*>(VT_SKINS);
		}
		flatbuffers::Vector<flatbuffers::Offset<Skin>>* mutable_skins()
		{
			return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Skin>>*>(VT_SKINS);
		}
		/// An array of textures.
		const flatbuffers::Vector<flatbuffers::Offset<Texture>>* textures() const
		{
			return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Texture>>*>(VT_TEXTURES);
		}
		flatbuffers::Vector<flatbuffers::Offset<Texture>>* mutable_textures()
		{
			return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Texture>>*>(VT_TEXTURES);
		}
		///-- glTFProperty
		/// Dictionary object with extension-specific objects.
		const flatbuffers::Vector<uint8_t>* extensions() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extensions()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTENSIONS);
		}
		flexbuffers::Reference extensions_flexbuffer_root() const
		{
			auto v = extensions();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		/// Application-specific data.
		const flatbuffers::Vector<uint8_t>* extras() const
		{
			return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flatbuffers::Vector<uint8_t>* mutable_extras()
		{
			return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_EXTRAS);
		}
		flexbuffers::Reference extras_flexbuffer_root() const
		{
			auto v = extras();
			return flexbuffers::GetRoot(v->Data(), v->size());
		}
		bool Verify(flatbuffers::Verifier& verifier) const
		{
			return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_EXTENSIONSUSED)
				   && verifier.Verify(extensionsUsed()) && verifier.VerifyVectorOfStrings(extensionsUsed())
				   && VerifyOffset(verifier, VT_EXTENSIONSREQUIRED) && verifier.Verify(extensionsRequired())
				   && verifier.VerifyVectorOfStrings(extensionsRequired()) && VerifyOffset(verifier, VT_ACCESSORS)
				   && verifier.Verify(accessors()) && verifier.VerifyVectorOfTables(accessors())
				   && VerifyOffset(verifier, VT_ANIMATIONS) && verifier.Verify(animations())
				   && verifier.VerifyVectorOfTables(animations()) && VerifyOffsetRequired(verifier, VT_ASSET)
				   && verifier.VerifyTable(asset()) && VerifyOffset(verifier, VT_BUFFERS) && verifier.Verify(buffers())
				   && verifier.VerifyVectorOfTables(buffers()) && VerifyOffset(verifier, VT_BUFFERVIEWS)
				   && verifier.Verify(bufferViews()) && verifier.VerifyVectorOfTables(bufferViews())
				   && VerifyOffset(verifier, VT_CAMERAS) && verifier.Verify(cameras())
				   && verifier.VerifyVectorOfTables(cameras()) && VerifyOffset(verifier, VT_IMAGES)
				   && verifier.Verify(images()) && verifier.VerifyVectorOfTables(images())
				   && VerifyOffset(verifier, VT_MATERIALS) && verifier.Verify(materials())
				   && verifier.VerifyVectorOfTables(materials()) && VerifyOffset(verifier, VT_MESHES)
				   && verifier.Verify(meshes()) && verifier.VerifyVectorOfTables(meshes()) && VerifyOffset(verifier, VT_NODES)
				   && verifier.Verify(nodes()) && verifier.VerifyVectorOfTables(nodes()) && VerifyOffset(verifier, VT_SAMPLERS)
				   && verifier.Verify(samplers()) && verifier.VerifyVectorOfTables(samplers())
				   && VerifyField<int32_t>(verifier, VT_SCENE) && VerifyOffset(verifier, VT_SCENES)
				   && verifier.Verify(scenes()) && verifier.VerifyVectorOfTables(scenes()) && VerifyOffset(verifier, VT_SKINS)
				   && verifier.Verify(skins()) && verifier.VerifyVectorOfTables(skins()) && VerifyOffset(verifier, VT_TEXTURES)
				   && verifier.Verify(textures()) && verifier.VerifyVectorOfTables(textures())
				   && VerifyOffset(verifier, VT_EXTENSIONS) && verifier.Verify(extensions())
				   && VerifyOffset(verifier, VT_EXTRAS) && verifier.Verify(extras()) && verifier.EndTable();
		}
		RootT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		void   UnPackTo(RootT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
		static flatbuffers::Offset<Root> Pack(flatbuffers::FlatBufferBuilder&		  _fbb,
											  const RootT*							  _o,
											  const flatbuffers::rehasher_function_t* _rehasher = nullptr);
	};

	struct RootBuilder
	{
		flatbuffers::FlatBufferBuilder& fbb_;
		flatbuffers::uoffset_t			start_;
		void add_extensionsUsed(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> extensionsUsed)
		{
			fbb_.AddOffset(Root::VT_EXTENSIONSUSED, extensionsUsed);
		}
		void add_extensionsRequired(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> extensionsRequired)
		{
			fbb_.AddOffset(Root::VT_EXTENSIONSREQUIRED, extensionsRequired);
		}
		void add_accessors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Accessor>>> accessors)
		{
			fbb_.AddOffset(Root::VT_ACCESSORS, accessors);
		}
		void add_animations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Animation>>> animations)
		{
			fbb_.AddOffset(Root::VT_ANIMATIONS, animations);
		}
		void add_asset(flatbuffers::Offset<Asset> asset)
		{
			fbb_.AddOffset(Root::VT_ASSET, asset);
		}
		void add_buffers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Buffer>>> buffers)
		{
			fbb_.AddOffset(Root::VT_BUFFERS, buffers);
		}
		void add_bufferViews(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BufferView>>> bufferViews)
		{
			fbb_.AddOffset(Root::VT_BUFFERVIEWS, bufferViews);
		}
		void add_cameras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Camera>>> cameras)
		{
			fbb_.AddOffset(Root::VT_CAMERAS, cameras);
		}
		void add_images(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Image>>> images)
		{
			fbb_.AddOffset(Root::VT_IMAGES, images);
		}
		void add_materials(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Material>>> materials)
		{
			fbb_.AddOffset(Root::VT_MATERIALS, materials);
		}
		void add_meshes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Mesh>>> meshes)
		{
			fbb_.AddOffset(Root::VT_MESHES, meshes);
		}
		void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Node>>> nodes)
		{
			fbb_.AddOffset(Root::VT_NODES, nodes);
		}
		void add_samplers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Sampler>>> samplers)
		{
			fbb_.AddOffset(Root::VT_SAMPLERS, samplers);
		}
		void add_scene(int32_t scene)
		{
			fbb_.AddElement<int32_t>(Root::VT_SCENE, scene, -1);
		}
		void add_scenes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Scene>>> scenes)
		{
			fbb_.AddOffset(Root::VT_SCENES, scenes);
		}
		void add_skins(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Skin>>> skins)
		{
			fbb_.AddOffset(Root::VT_SKINS, skins);
		}
		void add_textures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> textures)
		{
			fbb_.AddOffset(Root::VT_TEXTURES, textures);
		}
		void add_extensions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extensions)
		{
			fbb_.AddOffset(Root::VT_EXTENSIONS, extensions);
		}
		void add_extras(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extras)
		{
			fbb_.AddOffset(Root::VT_EXTRAS, extras);
		}
		RootBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		RootBuilder&			  operator=(const RootBuilder&);
		flatbuffers::Offset<Root> Finish()
		{
			const auto end = fbb_.EndTable(start_, 19);
			auto	   o   = flatbuffers::Offset<Root>(end);
			fbb_.Required(o, Root::VT_ASSET);
			return o;
		}
	};

	inline flatbuffers::Offset<Root>
	CreateRoot(flatbuffers::FlatBufferBuilder&													  _fbb,
			   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> extensionsUsed = 0,
			   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> extensionsRequired = 0,
			   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Accessor>>>			  accessors   = 0,
			   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Animation>>>			  animations  = 0,
			   flatbuffers::Offset<Asset>														  asset		  = 0,
			   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Buffer>>>			  buffers	 = 0,
			   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BufferView>>>		  bufferViews = 0,
			   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Camera>>>			  cameras	 = 0,
			   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Image>>>				  images	  = 0,
			   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Material>>>			  materials   = 0,
			   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Mesh>>>				  meshes	  = 0,
			   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Node>>>				  nodes		  = 0,
			   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Sampler>>>			  samplers	= 0,
			   int32_t																			  scene		  = -1,
			   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Scene>>>				  scenes	  = 0,
			   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Skin>>>				  skins		  = 0,
			   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>>			  textures	= 0,
			   flatbuffers::Offset<flatbuffers::Vector<uint8_t>>								  extensions  = 0,
			   flatbuffers::Offset<flatbuffers::Vector<uint8_t>>								  extras	  = 0)
	{
		RootBuilder builder_(_fbb);
		builder_.add_extras(extras);
		builder_.add_extensions(extensions);
		builder_.add_textures(textures);
		builder_.add_skins(skins);
		builder_.add_scenes(scenes);
		builder_.add_scene(scene);
		builder_.add_samplers(samplers);
		builder_.add_nodes(nodes);
		builder_.add_meshes(meshes);
		builder_.add_materials(materials);
		builder_.add_images(images);
		builder_.add_cameras(cameras);
		builder_.add_bufferViews(bufferViews);
		builder_.add_buffers(buffers);
		builder_.add_asset(asset);
		builder_.add_animations(animations);
		builder_.add_accessors(accessors);
		builder_.add_extensionsRequired(extensionsRequired);
		builder_.add_extensionsUsed(extensionsUsed);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<Root>
	CreateRootDirect(flatbuffers::FlatBufferBuilder&							  _fbb,
					 const std::vector<flatbuffers::Offset<flatbuffers::String>>* extensionsUsed	 = nullptr,
					 const std::vector<flatbuffers::Offset<flatbuffers::String>>* extensionsRequired = nullptr,
					 const std::vector<flatbuffers::Offset<Accessor>>*			  accessors			 = nullptr,
					 const std::vector<flatbuffers::Offset<Animation>>*			  animations		 = nullptr,
					 flatbuffers::Offset<Asset>									  asset				 = 0,
					 const std::vector<flatbuffers::Offset<Buffer>>*			  buffers			 = nullptr,
					 const std::vector<flatbuffers::Offset<BufferView>>*		  bufferViews		 = nullptr,
					 const std::vector<flatbuffers::Offset<Camera>>*			  cameras			 = nullptr,
					 const std::vector<flatbuffers::Offset<Image>>*				  images			 = nullptr,
					 const std::vector<flatbuffers::Offset<Material>>*			  materials			 = nullptr,
					 const std::vector<flatbuffers::Offset<Mesh>>*				  meshes			 = nullptr,
					 const std::vector<flatbuffers::Offset<Node>>*				  nodes				 = nullptr,
					 const std::vector<flatbuffers::Offset<Sampler>>*			  samplers			 = nullptr,
					 int32_t													  scene				 = -1,
					 const std::vector<flatbuffers::Offset<Scene>>*				  scenes			 = nullptr,
					 const std::vector<flatbuffers::Offset<Skin>>*				  skins				 = nullptr,
					 const std::vector<flatbuffers::Offset<Texture>>*			  textures			 = nullptr,
					 const std::vector<uint8_t>*								  extensions		 = nullptr,
					 const std::vector<uint8_t>*								  extras			 = nullptr)
	{
		return glTF_2_0::CreateRoot(_fbb,
									extensionsUsed ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*extensionsUsed) : 0,
									extensionsRequired ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*extensionsRequired) : 0,
									accessors ? _fbb.CreateVector<flatbuffers::Offset<Accessor>>(*accessors) : 0,
									animations ? _fbb.CreateVector<flatbuffers::Offset<Animation>>(*animations) : 0,
									asset,
									buffers ? _fbb.CreateVector<flatbuffers::Offset<Buffer>>(*buffers) : 0,
									bufferViews ? _fbb.CreateVector<flatbuffers::Offset<BufferView>>(*bufferViews) : 0,
									cameras ? _fbb.CreateVector<flatbuffers::Offset<Camera>>(*cameras) : 0,
									images ? _fbb.CreateVector<flatbuffers::Offset<Image>>(*images) : 0,
									materials ? _fbb.CreateVector<flatbuffers::Offset<Material>>(*materials) : 0,
									meshes ? _fbb.CreateVector<flatbuffers::Offset<Mesh>>(*meshes) : 0,
									nodes ? _fbb.CreateVector<flatbuffers::Offset<Node>>(*nodes) : 0,
									samplers ? _fbb.CreateVector<flatbuffers::Offset<Sampler>>(*samplers) : 0,
									scene,
									scenes ? _fbb.CreateVector<flatbuffers::Offset<Scene>>(*scenes) : 0,
									skins ? _fbb.CreateVector<flatbuffers::Offset<Skin>>(*skins) : 0,
									textures ? _fbb.CreateVector<flatbuffers::Offset<Texture>>(*textures) : 0,
									extensions ? _fbb.CreateVector<uint8_t>(*extensions) : 0,
									extras ? _fbb.CreateVector<uint8_t>(*extras) : 0);
	}

	flatbuffers::Offset<Root> CreateRoot(flatbuffers::FlatBufferBuilder&		 _fbb,
										 const RootT*							 _o,
										 const flatbuffers::rehasher_function_t* _rehasher = nullptr);

	inline AccessorSparseIndicesT* AccessorSparseIndices::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new AccessorSparseIndicesT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void AccessorSparseIndices::UnPackTo(AccessorSparseIndicesT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e		   = bufferView();
			_o->bufferView = _e;
		};
		{
			auto _e		  = byeOffset();
			_o->byeOffset = _e;
		};
		{
			auto _e			  = componentType();
			_o->componentType = _e;
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<AccessorSparseIndices> AccessorSparseIndices::Pack(flatbuffers::FlatBufferBuilder& _fbb,
																				  const AccessorSparseIndicesT*   _o,
																				  const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateAccessorSparseIndices(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<AccessorSparseIndices> CreateAccessorSparseIndices(flatbuffers::FlatBufferBuilder& _fbb,
																				  const AccessorSparseIndicesT*   _o,
																				  const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const AccessorSparseIndicesT*			__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _bufferView	= _o->bufferView;
		auto _byeOffset		= _o->byeOffset;
		auto _componentType = _o->componentType;
		auto _extensions	= _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras		= _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateAccessorSparseIndices(_fbb, _bufferView, _byeOffset, _componentType, _extensions, _extras);
	}

	inline AccessorSparseValuesT* AccessorSparseValues::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new AccessorSparseValuesT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void AccessorSparseValues::UnPackTo(AccessorSparseValuesT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e		   = bufferView();
			_o->bufferView = _e;
		};
		{
			auto _e		   = byteOffset();
			_o->byteOffset = _e;
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<AccessorSparseValues> AccessorSparseValues::Pack(flatbuffers::FlatBufferBuilder& _fbb,
																				const AccessorSparseValuesT*	_o,
																				const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateAccessorSparseValues(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<AccessorSparseValues> CreateAccessorSparseValues(flatbuffers::FlatBufferBuilder& _fbb,
																				const AccessorSparseValuesT*	_o,
																				const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const AccessorSparseValuesT*			__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _bufferView = _o->bufferView;
		auto _byteOffset = _o->byteOffset;
		auto _extensions = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	 = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateAccessorSparseValues(_fbb, _bufferView, _byteOffset, _extensions, _extras);
	}

	inline AccessorSparseT* AccessorSparse::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new AccessorSparseT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void AccessorSparse::UnPackTo(AccessorSparseT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e   = count();
			_o->count = _e;
		};
		{
			auto _e = indices();
			if (_e)
			{
				_o->indices.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->indices[_i] = std::unique_ptr<AccessorSparseIndicesT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		};
		{
			auto _e = values();
			if (_e)
			{
				_o->values.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->values[_i] = std::unique_ptr<AccessorSparseValuesT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<AccessorSparse> AccessorSparse::Pack(flatbuffers::FlatBufferBuilder&			_fbb,
																	const AccessorSparseT*					_o,
																	const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateAccessorSparse(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<AccessorSparse> CreateAccessorSparse(flatbuffers::FlatBufferBuilder&			_fbb,
																	const AccessorSparseT*					_o,
																	const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const AccessorSparseT*					__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _count   = _o->count;
		auto _indices = _fbb.CreateVector<flatbuffers::Offset<AccessorSparseIndices>>(
		  _o->indices.size(),
		  [](size_t i, _VectorArgs* __va) {
			  return CreateAccessorSparseIndices(*__va->__fbb, __va->__o->indices[i].get(), __va->__rehasher);
		  },
		  &_va);
		auto _values = _fbb.CreateVector<flatbuffers::Offset<AccessorSparseValues>>(
		  _o->values.size(),
		  [](size_t i, _VectorArgs* __va) {
			  return CreateAccessorSparseValues(*__va->__fbb, __va->__o->values[i].get(), __va->__rehasher);
		  },
		  &_va);
		auto _extensions = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	 = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateAccessorSparse(_fbb, _count, _indices, _values, _extensions, _extras);
	}

	inline AccessorT* Accessor::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new AccessorT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void Accessor::UnPackTo(AccessorT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e		   = bufferView();
			_o->bufferView = _e;
		};
		{
			auto _e		   = byteOffset();
			_o->byteOffset = _e;
		};
		{
			auto _e			  = componentType();
			_o->componentType = _e;
		};
		{
			auto _e		   = normalized();
			_o->normalized = _e;
		};
		{
			auto _e   = count();
			_o->count = _e;
		};
		{
			auto _e  = type();
			_o->type = _e;
		};
		{
			auto _e = max();
			if (_e)
			{
				_o->max.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->max[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = min();
			if (_e)
			{
				_o->min.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->min[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = sparse();
			if (_e)
			{
				_o->sparse.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->sparse[_i] = std::unique_ptr<AccessorSparseT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		};
		{
			auto _e = name();
			if (_e)
				_o->name = _e->str();
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<Accessor> Accessor::Pack(flatbuffers::FlatBufferBuilder&			_fbb,
														const AccessorT*						_o,
														const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateAccessor(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<Accessor> CreateAccessor(flatbuffers::FlatBufferBuilder&			_fbb,
														const AccessorT*						_o,
														const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const AccessorT*						__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _bufferView	= _o->bufferView;
		auto _byteOffset	= _o->byteOffset;
		auto _componentType = _o->componentType;
		auto _normalized	= _o->normalized;
		auto _count			= _o->count;
		auto _type			= _o->type;
		auto _max			= _o->max.size() ? _fbb.CreateVector(_o->max) : 0;
		auto _min			= _o->min.size() ? _fbb.CreateVector(_o->min) : 0;
		auto _sparse		= _o->sparse.size() ?
						 _fbb.CreateVector<flatbuffers::Offset<AccessorSparse>>(
						   _o->sparse.size(),
						   [](size_t i, _VectorArgs* __va) {
							   return CreateAccessorSparse(*__va->__fbb, __va->__o->sparse[i].get(), __va->__rehasher);
						   },
						   &_va) :
						 0;
		auto _name		 = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
		auto _extensions = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	 = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateAccessor(
		  _fbb, _bufferView, _byteOffset, _componentType, _normalized, _count, _type, _max, _min, _sparse, _name, _extensions, _extras);
	}

	inline AssetT* Asset::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new AssetT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void Asset::UnPackTo(AssetT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e = copyright();
			if (_e)
				_o->copyright = _e->str();
		};
		{
			auto _e = generator();
			if (_e)
				_o->generator = _e->str();
		};
		{
			auto _e = version();
			if (_e)
				_o->version = _e->str();
		};
		{
			auto _e = minVersion();
			if (_e)
				_o->minVersion = _e->str();
		};
		{
			auto _e = name();
			if (_e)
				_o->name = _e->str();
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<Asset> Asset::Pack(flatbuffers::FlatBufferBuilder&		  _fbb,
												  const AssetT*							  _o,
												  const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateAsset(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<Asset> CreateAsset(flatbuffers::FlatBufferBuilder&		  _fbb,
												  const AssetT*							  _o,
												  const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const AssetT*							__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _copyright  = _o->copyright.size() ? _fbb.CreateString(_o->copyright) : 0;
		auto _generator  = _o->generator.size() ? _fbb.CreateString(_o->generator) : 0;
		auto _version	= _fbb.CreateString(_o->version);
		auto _minVersion = _o->minVersion.size() ? _fbb.CreateString(_o->minVersion) : 0;
		auto _name		 = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
		auto _extensions = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	 = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateAsset(_fbb, _copyright, _generator, _version, _minVersion, _name, _extensions, _extras);
	}

	inline AnimationChannelTargetT* AnimationChannelTarget::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new AnimationChannelTargetT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void AnimationChannelTarget::UnPackTo(AnimationChannelTargetT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e  = node();
			_o->node = _e;
		};
		{
			auto _e  = path();
			_o->path = _e;
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<AnimationChannelTarget> AnimationChannelTarget::Pack(flatbuffers::FlatBufferBuilder& _fbb,
																					const AnimationChannelTargetT*  _o,
																					const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateAnimationChannelTarget(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<AnimationChannelTarget> CreateAnimationChannelTarget(flatbuffers::FlatBufferBuilder& _fbb,
																					const AnimationChannelTargetT*  _o,
																					const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const AnimationChannelTargetT*			__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _node		 = _o->node;
		auto _path		 = _o->path;
		auto _extensions = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	 = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateAnimationChannelTarget(_fbb, _node, _path, _extensions, _extras);
	}

	inline AnimationChannelT* AnimationChannel::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new AnimationChannelT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void AnimationChannel::UnPackTo(AnimationChannelT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e		= sampler();
			_o->sampler = _e;
		};
		{
			auto _e = target();
			if (_e)
				_o->target = std::unique_ptr<AnimationChannelTargetT>(_e->UnPack(_resolver));
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<AnimationChannel> AnimationChannel::Pack(flatbuffers::FlatBufferBuilder&			_fbb,
																		const AnimationChannelT*				_o,
																		const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateAnimationChannel(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<AnimationChannel> CreateAnimationChannel(flatbuffers::FlatBufferBuilder&			_fbb,
																		const AnimationChannelT*				_o,
																		const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const AnimationChannelT*				__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _sampler	= _o->sampler;
		auto _target	 = _o->target ? CreateAnimationChannelTarget(_fbb, _o->target.get(), _rehasher) : 0;
		auto _extensions = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	 = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateAnimationChannel(_fbb, _sampler, _target, _extensions, _extras);
	}

	inline AnimationSamplerT* AnimationSampler::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new AnimationSamplerT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void AnimationSampler::UnPackTo(AnimationSamplerT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e   = input();
			_o->input = _e;
		};
		{
			auto _e			  = interpolation();
			_o->interpolation = _e;
		};
		{
			auto _e	= output();
			_o->output = _e;
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<AnimationSampler> AnimationSampler::Pack(flatbuffers::FlatBufferBuilder&			_fbb,
																		const AnimationSamplerT*				_o,
																		const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateAnimationSampler(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<AnimationSampler> CreateAnimationSampler(flatbuffers::FlatBufferBuilder&			_fbb,
																		const AnimationSamplerT*				_o,
																		const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const AnimationSamplerT*				__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _input			= _o->input;
		auto _interpolation = _o->interpolation;
		auto _output		= _o->output;
		auto _extensions	= _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras		= _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateAnimationSampler(_fbb, _input, _interpolation, _output, _extensions, _extras);
	}

	inline AnimationT* Animation::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new AnimationT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void Animation::UnPackTo(AnimationT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e = channels();
			if (_e)
			{
				_o->channels.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->channels[_i] = std::unique_ptr<AnimationChannelT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		};
		{
			auto _e = samplers();
			if (_e)
			{
				_o->samplers.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->samplers[_i] = std::unique_ptr<AnimationSamplerT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		};
		{
			auto _e = name();
			if (_e)
				_o->name = _e->str();
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<Animation> Animation::Pack(flatbuffers::FlatBufferBuilder&		  _fbb,
														  const AnimationT*						  _o,
														  const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateAnimation(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<Animation> CreateAnimation(flatbuffers::FlatBufferBuilder&		  _fbb,
														  const AnimationT*						  _o,
														  const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const AnimationT*						__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _channels = _fbb.CreateVector<flatbuffers::Offset<AnimationChannel>>(
		  _o->channels.size(),
		  [](size_t i, _VectorArgs* __va) {
			  return CreateAnimationChannel(*__va->__fbb, __va->__o->channels[i].get(), __va->__rehasher);
		  },
		  &_va);
		auto _samplers = _fbb.CreateVector<flatbuffers::Offset<AnimationSampler>>(
		  _o->samplers.size(),
		  [](size_t i, _VectorArgs* __va) {
			  return CreateAnimationSampler(*__va->__fbb, __va->__o->samplers[i].get(), __va->__rehasher);
		  },
		  &_va);
		auto _name		 = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
		auto _extensions = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	 = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateAnimation(_fbb, _channels, _samplers, _name, _extensions, _extras);
	}

	inline BufferT* Buffer::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new BufferT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void Buffer::UnPackTo(BufferT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e = uri();
			if (_e)
				_o->uri = _e->str();
		};
		{
			auto _e		   = byteLength();
			_o->byteLength = _e;
		};
		{
			auto _e = name();
			if (_e)
				_o->name = _e->str();
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<Buffer> Buffer::Pack(flatbuffers::FlatBufferBuilder&			_fbb,
													const BufferT*							_o,
													const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateBuffer(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<Buffer> CreateBuffer(flatbuffers::FlatBufferBuilder&			_fbb,
													const BufferT*							_o,
													const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const BufferT*							__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _uri		 = _o->uri.size() ? _fbb.CreateString(_o->uri) : 0;
		auto _byteLength = _o->byteLength;
		auto _name		 = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
		auto _extensions = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	 = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateBuffer(_fbb, _uri, _byteLength, _name, _extensions, _extras);
	}

	inline BufferViewT* BufferView::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new BufferViewT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void BufferView::UnPackTo(BufferViewT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e	= buffer();
			_o->buffer = _e;
		};
		{
			auto _e		   = byteOffset();
			_o->byteOffset = _e;
		};
		{
			auto _e		   = byteLength();
			_o->byteLength = _e;
		};
		{
			auto _e		   = byteStride();
			_o->byteStride = _e;
		};
		{
			auto _e	= target();
			_o->target = _e;
		};
		{
			auto _e = name();
			if (_e)
				_o->name = _e->str();
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<BufferView> BufferView::Pack(flatbuffers::FlatBufferBuilder&			_fbb,
															const BufferViewT*						_o,
															const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateBufferView(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<BufferView> CreateBufferView(flatbuffers::FlatBufferBuilder&			_fbb,
															const BufferViewT*						_o,
															const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const BufferViewT*						__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _buffer	 = _o->buffer;
		auto _byteOffset = _o->byteOffset;
		auto _byteLength = _o->byteLength;
		auto _byteStride = _o->byteStride;
		auto _target	 = _o->target;
		auto _name		 = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
		auto _extensions = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	 = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateBufferView(_fbb, _buffer, _byteOffset, _byteLength, _byteStride, _target, _name, _extensions, _extras);
	}

	inline CameraOrthographicT* CameraOrthographic::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new CameraOrthographicT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void CameraOrthographic::UnPackTo(CameraOrthographicT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e  = xmag();
			_o->xmag = _e;
		};
		{
			auto _e  = ymag();
			_o->ymag = _e;
		};
		{
			auto _e  = zfar();
			_o->zfar = _e;
		};
		{
			auto _e   = znear();
			_o->znear = _e;
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<CameraOrthographic> CameraOrthographic::Pack(flatbuffers::FlatBufferBuilder& _fbb,
																			const CameraOrthographicT*		_o,
																			const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateCameraOrthographic(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<CameraOrthographic> CreateCameraOrthographic(flatbuffers::FlatBufferBuilder& _fbb,
																			const CameraOrthographicT*		_o,
																			const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const CameraOrthographicT*				__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _xmag		 = _o->xmag;
		auto _ymag		 = _o->ymag;
		auto _zfar		 = _o->zfar;
		auto _znear		 = _o->znear;
		auto _extensions = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	 = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateCameraOrthographic(_fbb, _xmag, _ymag, _zfar, _znear, _extensions, _extras);
	}

	inline CameraPerspectiveT* CameraPerspective::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new CameraPerspectiveT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void CameraPerspective::UnPackTo(CameraPerspectiveT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e			= aspectRatio();
			_o->aspectRatio = _e;
		};
		{
			auto _e  = yfov();
			_o->yfov = _e;
		};
		{
			auto _e  = zfar();
			_o->zfar = _e;
		};
		{
			auto _e   = znear();
			_o->znear = _e;
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<CameraPerspective> CameraPerspective::Pack(flatbuffers::FlatBufferBuilder&		  _fbb,
																		  const CameraPerspectiveT*				  _o,
																		  const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateCameraPerspective(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<CameraPerspective> CreateCameraPerspective(flatbuffers::FlatBufferBuilder&		  _fbb,
																		  const CameraPerspectiveT*				  _o,
																		  const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const CameraPerspectiveT*				__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _aspectRatio = _o->aspectRatio;
		auto _yfov		  = _o->yfov;
		auto _zfar		  = _o->zfar;
		auto _znear		  = _o->znear;
		auto _extensions  = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	  = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateCameraPerspective(_fbb, _aspectRatio, _yfov, _zfar, _znear, _extensions, _extras);
	}

	inline CameraT* Camera::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new CameraT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void Camera::UnPackTo(CameraT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e = orthographic();
			if (_e)
				_o->orthographic = std::unique_ptr<CameraOrthographicT>(_e->UnPack(_resolver));
		};
		{
			auto _e = perspective();
			if (_e)
				_o->perspective = std::unique_ptr<CameraPerspectiveT>(_e->UnPack(_resolver));
		};
		{
			auto _e  = type();
			_o->type = _e;
		};
		{
			auto _e = name();
			if (_e)
				_o->name = _e->str();
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<Camera> Camera::Pack(flatbuffers::FlatBufferBuilder&			_fbb,
													const CameraT*							_o,
													const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateCamera(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<Camera> CreateCamera(flatbuffers::FlatBufferBuilder&			_fbb,
													const CameraT*							_o,
													const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const CameraT*							__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _orthographic = _o->orthographic ? CreateCameraOrthographic(_fbb, _o->orthographic.get(), _rehasher) : 0;
		auto _perspective  = _o->perspective ? CreateCameraPerspective(_fbb, _o->perspective.get(), _rehasher) : 0;
		auto _type		   = _o->type;
		auto _name		   = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
		auto _extensions   = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	   = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateCamera(_fbb, _orthographic, _perspective, _type, _name, _extensions, _extras);
	}

	inline ImageT* Image::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new ImageT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void Image::UnPackTo(ImageT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e = uri();
			if (_e)
				_o->uri = _e->str();
		};
		{
			auto _e = mimeType();
			if (_e)
				_o->mimeType = _e->str();
		};
		{
			auto _e		   = bufferView();
			_o->bufferView = _e;
		};
		{
			auto _e = name();
			if (_e)
				_o->name = _e->str();
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<Image> Image::Pack(flatbuffers::FlatBufferBuilder&		  _fbb,
												  const ImageT*							  _o,
												  const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateImage(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<Image> CreateImage(flatbuffers::FlatBufferBuilder&		  _fbb,
												  const ImageT*							  _o,
												  const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const ImageT*							__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _uri		 = _o->uri.size() ? _fbb.CreateString(_o->uri) : 0;
		auto _mimeType   = _o->mimeType.size() ? _fbb.CreateString(_o->mimeType) : 0;
		auto _bufferView = _o->bufferView;
		auto _name		 = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
		auto _extensions = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	 = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateImage(_fbb, _uri, _mimeType, _bufferView, _name, _extensions, _extras);
	}

	inline TextureInfoT* TextureInfo::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new TextureInfoT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void TextureInfo::UnPackTo(TextureInfoT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e   = index();
			_o->index = _e;
		};
		{
			auto _e		 = texCoord();
			_o->texCoord = _e;
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<TextureInfo> TextureInfo::Pack(flatbuffers::FlatBufferBuilder&		  _fbb,
															  const TextureInfoT*					  _o,
															  const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateTextureInfo(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<TextureInfo> CreateTextureInfo(flatbuffers::FlatBufferBuilder&		  _fbb,
															  const TextureInfoT*					  _o,
															  const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const TextureInfoT*						__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _index		 = _o->index;
		auto _texCoord   = _o->texCoord;
		auto _extensions = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	 = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateTextureInfo(_fbb, _index, _texCoord, _extensions, _extras);
	}

	inline MaterialNormalTextureInfoT* MaterialNormalTextureInfo::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new MaterialNormalTextureInfoT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void MaterialNormalTextureInfo::UnPackTo(MaterialNormalTextureInfoT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e   = scale();
			_o->scale = _e;
		};
		{
			auto _e   = index();
			_o->index = _e;
		};
		{
			auto _e		 = texCoord();
			_o->texCoord = _e;
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<MaterialNormalTextureInfo> MaterialNormalTextureInfo::Pack(
	  flatbuffers::FlatBufferBuilder& _fbb, const MaterialNormalTextureInfoT* _o, const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateMaterialNormalTextureInfo(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<MaterialNormalTextureInfo> CreateMaterialNormalTextureInfo(
	  flatbuffers::FlatBufferBuilder& _fbb, const MaterialNormalTextureInfoT* _o, const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const MaterialNormalTextureInfoT*		__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _scale		 = _o->scale;
		auto _index		 = _o->index;
		auto _texCoord   = _o->texCoord;
		auto _extensions = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	 = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateMaterialNormalTextureInfo(_fbb, _scale, _index, _texCoord, _extensions, _extras);
	}

	inline MaterialOcclusionTextureInfoT* MaterialOcclusionTextureInfo::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new MaterialOcclusionTextureInfoT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void MaterialOcclusionTextureInfo::UnPackTo(MaterialOcclusionTextureInfoT*		   _o,
													   const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e		 = strength();
			_o->strength = _e;
		};
		{
			auto _e   = index();
			_o->index = _e;
		};
		{
			auto _e		 = texCoord();
			_o->texCoord = _e;
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<MaterialOcclusionTextureInfo> MaterialOcclusionTextureInfo::Pack(
	  flatbuffers::FlatBufferBuilder& _fbb, const MaterialOcclusionTextureInfoT* _o, const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateMaterialOcclusionTextureInfo(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<MaterialOcclusionTextureInfo> CreateMaterialOcclusionTextureInfo(
	  flatbuffers::FlatBufferBuilder& _fbb, const MaterialOcclusionTextureInfoT* _o, const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const MaterialOcclusionTextureInfoT*	__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _strength   = _o->strength;
		auto _index		 = _o->index;
		auto _texCoord   = _o->texCoord;
		auto _extensions = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	 = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateMaterialOcclusionTextureInfo(_fbb, _strength, _index, _texCoord, _extensions, _extras);
	}

	inline MaterialPbrMetallicRoughnessT* MaterialPbrMetallicRoughness::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new MaterialPbrMetallicRoughnessT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void MaterialPbrMetallicRoughness::UnPackTo(MaterialPbrMetallicRoughnessT*		   _o,
													   const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e = baseColorFactor();
			if (_e)
			{
				_o->baseColorFactor.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->baseColorFactor[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = baseColorTexture();
			if (_e)
				_o->baseColorTexture = std::unique_ptr<TextureInfoT>(_e->UnPack(_resolver));
		};
		{
			auto _e			   = metallicFactor();
			_o->metallicFactor = _e;
		};
		{
			auto _e				= roughnessFactor();
			_o->roughnessFactor = _e;
		};
		{
			auto _e = metallicRoughnessTexture();
			if (_e)
				_o->metallicRoughnessTexture = std::unique_ptr<TextureInfoT>(_e->UnPack(_resolver));
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<MaterialPbrMetallicRoughness> MaterialPbrMetallicRoughness::Pack(
	  flatbuffers::FlatBufferBuilder& _fbb, const MaterialPbrMetallicRoughnessT* _o, const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateMaterialPbrMetallicRoughness(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<MaterialPbrMetallicRoughness> CreateMaterialPbrMetallicRoughness(
	  flatbuffers::FlatBufferBuilder& _fbb, const MaterialPbrMetallicRoughnessT* _o, const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const MaterialPbrMetallicRoughnessT*	__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _baseColorFactor = _o->baseColorFactor.size() ? _fbb.CreateVector(_o->baseColorFactor) : 0;
		auto _baseColorTexture = _o->baseColorTexture ? CreateTextureInfo(_fbb, _o->baseColorTexture.get(), _rehasher) : 0;
		auto _metallicFactor  = _o->metallicFactor;
		auto _roughnessFactor = _o->roughnessFactor;
		auto _metallicRoughnessTexture
		  = _o->metallicRoughnessTexture ? CreateTextureInfo(_fbb, _o->metallicRoughnessTexture.get(), _rehasher) : 0;
		auto _extensions = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	 = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateMaterialPbrMetallicRoughness(
		  _fbb, _baseColorFactor, _baseColorTexture, _metallicFactor, _roughnessFactor, _metallicRoughnessTexture, _extensions, _extras);
	}

	inline MaterialT* Material::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new MaterialT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void Material::UnPackTo(MaterialT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e = pbrMetallicRoughness();
			if (_e)
				_o->pbrMetallicRoughness = std::unique_ptr<MaterialPbrMetallicRoughnessT>(_e->UnPack(_resolver));
		};
		{
			auto _e = normalTexture();
			if (_e)
				_o->normalTexture = std::unique_ptr<MaterialNormalTextureInfoT>(_e->UnPack(_resolver));
		};
		{
			auto _e = occlusionTexture();
			if (_e)
				_o->occlusionTexture = std::unique_ptr<MaterialOcclusionTextureInfoT>(_e->UnPack(_resolver));
		};
		{
			auto _e = emissiveTexture();
			if (_e)
				_o->emissiveTexture = std::unique_ptr<TextureInfoT>(_e->UnPack(_resolver));
		};
		{
			auto _e = emissiveFactor();
			if (_e)
			{
				_o->emissiveFactor.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->emissiveFactor[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e		  = alphaMode();
			_o->alphaMode = _e;
		};
		{
			auto _e			= alphaCutoff();
			_o->alphaCutoff = _e;
		};
		{
			auto _e			= doubleSided();
			_o->doubleSided = _e;
		};
		{
			auto _e = name();
			if (_e)
				_o->name = _e->str();
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<Material> Material::Pack(flatbuffers::FlatBufferBuilder&			_fbb,
														const MaterialT*						_o,
														const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateMaterial(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<Material> CreateMaterial(flatbuffers::FlatBufferBuilder&			_fbb,
														const MaterialT*						_o,
														const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const MaterialT*						__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _pbrMetallicRoughness
		  = _o->pbrMetallicRoughness ? CreateMaterialPbrMetallicRoughness(_fbb, _o->pbrMetallicRoughness.get(), _rehasher) : 0;
		auto _normalTexture = _o->normalTexture ? CreateMaterialNormalTextureInfo(_fbb, _o->normalTexture.get(), _rehasher) : 0;
		auto _occlusionTexture
		  = _o->occlusionTexture ? CreateMaterialOcclusionTextureInfo(_fbb, _o->occlusionTexture.get(), _rehasher) : 0;
		auto _emissiveTexture = _o->emissiveTexture ? CreateTextureInfo(_fbb, _o->emissiveTexture.get(), _rehasher) : 0;
		auto _emissiveFactor  = _o->emissiveFactor.size() ? _fbb.CreateVector(_o->emissiveFactor) : 0;
		auto _alphaMode		  = _o->alphaMode;
		auto _alphaCutoff	 = _o->alphaCutoff;
		auto _doubleSided	 = _o->doubleSided;
		auto _name			  = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
		auto _extensions	  = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras		  = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateMaterial(_fbb,
										_pbrMetallicRoughness,
										_normalTexture,
										_occlusionTexture,
										_emissiveTexture,
										_emissiveFactor,
										_alphaMode,
										_alphaCutoff,
										_doubleSided,
										_name,
										_extensions,
										_extras);
	}

	inline MeshPrimitiveAttributeT* MeshPrimitiveAttribute::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new MeshPrimitiveAttributeT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void MeshPrimitiveAttribute::UnPackTo(MeshPrimitiveAttributeT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e = id();
			if (_e)
				_o->id = _e->str();
		};
		{
			auto _e   = value();
			_o->value = _e;
		};
	}

	inline flatbuffers::Offset<MeshPrimitiveAttribute> MeshPrimitiveAttribute::Pack(flatbuffers::FlatBufferBuilder& _fbb,
																					const MeshPrimitiveAttributeT*  _o,
																					const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateMeshPrimitiveAttribute(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<MeshPrimitiveAttribute> CreateMeshPrimitiveAttribute(flatbuffers::FlatBufferBuilder& _fbb,
																					const MeshPrimitiveAttributeT*  _o,
																					const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const MeshPrimitiveAttributeT*			__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _id	= _fbb.CreateString(_o->id);
		auto _value = _o->value;
		return glTF_2_0::CreateMeshPrimitiveAttribute(_fbb, _id, _value);
	}

	inline MeshPrimitiveT* MeshPrimitive::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new MeshPrimitiveT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void MeshPrimitive::UnPackTo(MeshPrimitiveT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e = attributes();
			if (_e)
			{
				_o->attributes.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->attributes[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e		= indices();
			_o->indices = _e;
		};
		{
			auto _e		 = material();
			_o->material = _e;
		};
		{
			auto _e  = mode();
			_o->mode = _e;
		};
		{
			auto _e = targets();
			if (_e)
			{
				_o->targets.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->targets[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<MeshPrimitive> MeshPrimitive::Pack(flatbuffers::FlatBufferBuilder&		  _fbb,
																  const MeshPrimitiveT*					  _o,
																  const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateMeshPrimitive(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<MeshPrimitive> CreateMeshPrimitive(flatbuffers::FlatBufferBuilder&		  _fbb,
																  const MeshPrimitiveT*					  _o,
																  const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const MeshPrimitiveT*					__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _attributes = _fbb.CreateVector(_o->attributes);
		auto _indices	= _o->indices;
		auto _material   = _o->material;
		auto _mode		 = _o->mode;
		auto _targets	= _o->targets.size() ? _fbb.CreateVector(_o->targets) : 0;
		auto _extensions = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	 = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateMeshPrimitive(_fbb, _attributes, _indices, _material, _mode, _targets, _extensions, _extras);
	}

	inline MeshT* Mesh::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new MeshT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void Mesh::UnPackTo(MeshT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e = primitives();
			if (_e)
			{
				_o->primitives.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->primitives[_i] = std::unique_ptr<MeshPrimitiveT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		};
		{
			auto _e = weights();
			if (_e)
			{
				_o->weights.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->weights[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = name();
			if (_e)
				_o->name = _e->str();
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<Mesh> Mesh::Pack(flatbuffers::FlatBufferBuilder&			_fbb,
												const MeshT*							_o,
												const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateMesh(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<Mesh> CreateMesh(flatbuffers::FlatBufferBuilder&			_fbb,
												const MeshT*							_o,
												const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const MeshT*							__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _primitives = _fbb.CreateVector<flatbuffers::Offset<MeshPrimitive>>(
		  _o->primitives.size(),
		  [](size_t i, _VectorArgs* __va) {
			  return CreateMeshPrimitive(*__va->__fbb, __va->__o->primitives[i].get(), __va->__rehasher);
		  },
		  &_va);
		auto _weights	= _o->weights.size() ? _fbb.CreateVector(_o->weights) : 0;
		auto _name		 = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
		auto _extensions = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	 = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateMesh(_fbb, _primitives, _weights, _name, _extensions, _extras);
	}

	inline NodeT* Node::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new NodeT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void Node::UnPackTo(NodeT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e	= camera();
			_o->camera = _e;
		};
		{
			auto _e = children();
			if (_e)
			{
				_o->children.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->children[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e  = skin();
			_o->skin = _e;
		};
		{
			auto _e = matrix();
			if (_e)
			{
				_o->matrix.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->matrix[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e  = mesh();
			_o->mesh = _e;
		};
		{
			auto _e = rotation();
			if (_e)
			{
				_o->rotation.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->rotation[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = scale();
			if (_e)
			{
				_o->scale.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->scale[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = translation();
			if (_e)
			{
				_o->translation.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->translation[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = weights();
			if (_e)
			{
				_o->weights.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->weights[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = name();
			if (_e)
				_o->name = _e->str();
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<Node> Node::Pack(flatbuffers::FlatBufferBuilder&			_fbb,
												const NodeT*							_o,
												const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateNode(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<Node> CreateNode(flatbuffers::FlatBufferBuilder&			_fbb,
												const NodeT*							_o,
												const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const NodeT*							__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _camera	  = _o->camera;
		auto _children	= _o->children.size() ? _fbb.CreateVector(_o->children) : 0;
		auto _skin		  = _o->skin;
		auto _matrix	  = _o->matrix.size() ? _fbb.CreateVector(_o->matrix) : 0;
		auto _mesh		  = _o->mesh;
		auto _rotation	= _o->rotation.size() ? _fbb.CreateVector(_o->rotation) : 0;
		auto _scale		  = _o->scale.size() ? _fbb.CreateVector(_o->scale) : 0;
		auto _translation = _o->translation.size() ? _fbb.CreateVector(_o->translation) : 0;
		auto _weights	 = _o->weights.size() ? _fbb.CreateVector(_o->weights) : 0;
		auto _name		  = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
		auto _extensions  = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	  = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateNode(
		  _fbb, _camera, _children, _skin, _matrix, _mesh, _rotation, _scale, _translation, _weights, _name, _extensions, _extras);
	}

	inline SceneT* Scene::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new SceneT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void Scene::UnPackTo(SceneT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e = nodes();
			if (_e)
			{
				_o->nodes.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->nodes[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = name();
			if (_e)
				_o->name = _e->str();
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<Scene> Scene::Pack(flatbuffers::FlatBufferBuilder&		  _fbb,
												  const SceneT*							  _o,
												  const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateScene(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<Scene> CreateScene(flatbuffers::FlatBufferBuilder&		  _fbb,
												  const SceneT*							  _o,
												  const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const SceneT*							__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _nodes		 = _o->nodes.size() ? _fbb.CreateVector(_o->nodes) : 0;
		auto _name		 = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
		auto _extensions = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	 = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateScene(_fbb, _nodes, _name, _extensions, _extras);
	}

	inline SamplerT* Sampler::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new SamplerT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void Sampler::UnPackTo(SamplerT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e		  = magFilter();
			_o->magFilter = _e;
		};
		{
			auto _e		  = minFilter();
			_o->minFilter = _e;
		};
		{
			auto _e   = wrapS();
			_o->wrapS = _e;
		};
		{
			auto _e   = wrapT();
			_o->wrapT = _e;
		};
		{
			auto _e = name();
			if (_e)
				_o->name = _e->str();
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<Sampler> Sampler::Pack(flatbuffers::FlatBufferBuilder&		  _fbb,
													  const SamplerT*						  _o,
													  const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateSampler(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<Sampler> CreateSampler(flatbuffers::FlatBufferBuilder&		  _fbb,
													  const SamplerT*						  _o,
													  const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const SamplerT*							__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _magFilter  = _o->magFilter;
		auto _minFilter  = _o->minFilter;
		auto _wrapS		 = _o->wrapS;
		auto _wrapT		 = _o->wrapT;
		auto _name		 = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
		auto _extensions = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	 = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateSampler(_fbb, _magFilter, _minFilter, _wrapS, _wrapT, _name, _extensions, _extras);
	}

	inline TextureT* Texture::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new TextureT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void Texture::UnPackTo(TextureT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e		= sampler();
			_o->sampler = _e;
		};
		{
			auto _e	= source();
			_o->source = _e;
		};
		{
			auto _e = name();
			if (_e)
				_o->name = _e->str();
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<Texture> Texture::Pack(flatbuffers::FlatBufferBuilder&		  _fbb,
													  const TextureT*						  _o,
													  const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateTexture(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<Texture> CreateTexture(flatbuffers::FlatBufferBuilder&		  _fbb,
													  const TextureT*						  _o,
													  const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const TextureT*							__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _sampler	= _o->sampler;
		auto _source	 = _o->source;
		auto _name		 = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
		auto _extensions = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	 = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateTexture(_fbb, _sampler, _source, _name, _extensions, _extras);
	}

	inline SkinT* Skin::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new SkinT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void Skin::UnPackTo(SkinT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e					= inverseBindMatrices();
			_o->inverseBindMatrices = _e;
		};
		{
			auto _e		 = skeleton();
			_o->skeleton = _e;
		};
		{
			auto _e = joints();
			if (_e)
			{
				_o->joints.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->joints[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = name();
			if (_e)
				_o->name = _e->str();
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<Skin> Skin::Pack(flatbuffers::FlatBufferBuilder&			_fbb,
												const SkinT*							_o,
												const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateSkin(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<Skin> CreateSkin(flatbuffers::FlatBufferBuilder&			_fbb,
												const SkinT*							_o,
												const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const SkinT*							__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _inverseBindMatrices = _o->inverseBindMatrices;
		auto _skeleton			  = _o->skeleton;
		auto _joints			  = _fbb.CreateVector(_o->joints);
		auto _name				  = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
		auto _extensions		  = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras			  = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateSkin(_fbb, _inverseBindMatrices, _skeleton, _joints, _name, _extensions, _extras);
	}

	inline RootT* Root::UnPack(const flatbuffers::resolver_function_t* _resolver) const
	{
		auto _o = new RootT();
		UnPackTo(_o, _resolver);
		return _o;
	}

	inline void Root::UnPackTo(RootT* _o, const flatbuffers::resolver_function_t* _resolver) const
	{
		(void)_o;
		(void)_resolver;
		{
			auto _e = extensionsUsed();
			if (_e)
			{
				_o->extensionsUsed.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensionsUsed[_i] = _e->Get(_i)->str();
				}
			}
		};
		{
			auto _e = extensionsRequired();
			if (_e)
			{
				_o->extensionsRequired.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensionsRequired[_i] = _e->Get(_i)->str();
				}
			}
		};
		{
			auto _e = accessors();
			if (_e)
			{
				_o->accessors.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->accessors[_i] = std::unique_ptr<AccessorT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		};
		{
			auto _e = animations();
			if (_e)
			{
				_o->animations.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->animations[_i] = std::unique_ptr<AnimationT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		};
		{
			auto _e = asset();
			if (_e)
				_o->asset = std::unique_ptr<AssetT>(_e->UnPack(_resolver));
		};
		{
			auto _e = buffers();
			if (_e)
			{
				_o->buffers.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->buffers[_i] = std::unique_ptr<BufferT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		};
		{
			auto _e = bufferViews();
			if (_e)
			{
				_o->bufferViews.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->bufferViews[_i] = std::unique_ptr<BufferViewT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		};
		{
			auto _e = cameras();
			if (_e)
			{
				_o->cameras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->cameras[_i] = std::unique_ptr<CameraT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		};
		{
			auto _e = images();
			if (_e)
			{
				_o->images.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->images[_i] = std::unique_ptr<ImageT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		};
		{
			auto _e = materials();
			if (_e)
			{
				_o->materials.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->materials[_i] = std::unique_ptr<MaterialT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		};
		{
			auto _e = meshes();
			if (_e)
			{
				_o->meshes.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->meshes[_i] = std::unique_ptr<MeshT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		};
		{
			auto _e = nodes();
			if (_e)
			{
				_o->nodes.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->nodes[_i] = std::unique_ptr<NodeT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		};
		{
			auto _e = samplers();
			if (_e)
			{
				_o->samplers.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->samplers[_i] = std::unique_ptr<SamplerT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		};
		{
			auto _e   = scene();
			_o->scene = _e;
		};
		{
			auto _e = scenes();
			if (_e)
			{
				_o->scenes.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->scenes[_i] = std::unique_ptr<SceneT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		};
		{
			auto _e = skins();
			if (_e)
			{
				_o->skins.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->skins[_i] = std::unique_ptr<SkinT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		};
		{
			auto _e = textures();
			if (_e)
			{
				_o->textures.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->textures[_i] = std::unique_ptr<TextureT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		};
		{
			auto _e = extensions();
			if (_e)
			{
				_o->extensions.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extensions[_i] = _e->Get(_i);
				}
			}
		};
		{
			auto _e = extras();
			if (_e)
			{
				_o->extras.resize(_e->size());
				for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
				{
					_o->extras[_i] = _e->Get(_i);
				}
			}
		};
	}

	inline flatbuffers::Offset<Root> Root::Pack(flatbuffers::FlatBufferBuilder&			_fbb,
												const RootT*							_o,
												const flatbuffers::rehasher_function_t* _rehasher)
	{
		return CreateRoot(_fbb, _o, _rehasher);
	}

	inline flatbuffers::Offset<Root> CreateRoot(flatbuffers::FlatBufferBuilder&			_fbb,
												const RootT*							_o,
												const flatbuffers::rehasher_function_t* _rehasher)
	{
		(void)_rehasher;
		(void)_o;
		struct _VectorArgs
		{
			flatbuffers::FlatBufferBuilder*			__fbb;
			const RootT*							__o;
			const flatbuffers::rehasher_function_t* __rehasher;
		} _va = {&_fbb, _o, _rehasher};
		(void)_va;
		auto _extensionsUsed	 = _o->extensionsUsed.size() ? _fbb.CreateVectorOfStrings(_o->extensionsUsed) : 0;
		auto _extensionsRequired = _o->extensionsRequired.size() ? _fbb.CreateVectorOfStrings(_o->extensionsRequired) : 0;
		auto _accessors
		  = _o->accessors.size() ?
			  _fbb.CreateVector<flatbuffers::Offset<Accessor>>(_o->accessors.size(),
															   [](size_t i, _VectorArgs* __va) {
																   return CreateAccessor(*__va->__fbb,
																						 __va->__o->accessors[i].get(),
																						 __va->__rehasher);
															   },
															   &_va) :
			  0;
		auto _animations
		  = _o->animations.size() ?
			  _fbb.CreateVector<flatbuffers::Offset<Animation>>(_o->animations.size(),
																[](size_t i, _VectorArgs* __va) {
																	return CreateAnimation(*__va->__fbb,
																						   __va->__o->animations[i].get(),
																						   __va->__rehasher);
																},
																&_va) :
			  0;
		auto _asset   = _o->asset ? CreateAsset(_fbb, _o->asset.get(), _rehasher) : 0;
		auto _buffers = _o->buffers.size() ?
						  _fbb.CreateVector<flatbuffers::Offset<Buffer>>(_o->buffers.size(),
																		 [](size_t i, _VectorArgs* __va) {
																			 return CreateBuffer(*__va->__fbb,
																								 __va->__o->buffers[i].get(),
																								 __va->__rehasher);
																		 },
																		 &_va) :
						  0;
		auto _bufferViews
		  = _o->bufferViews.size() ?
			  _fbb.CreateVector<flatbuffers::Offset<BufferView>>(_o->bufferViews.size(),
																 [](size_t i, _VectorArgs* __va) {
																	 return CreateBufferView(*__va->__fbb,
																							 __va->__o->bufferViews[i].get(),
																							 __va->__rehasher);
																 },
																 &_va) :
			  0;
		auto _cameras = _o->cameras.size() ?
						  _fbb.CreateVector<flatbuffers::Offset<Camera>>(_o->cameras.size(),
																		 [](size_t i, _VectorArgs* __va) {
																			 return CreateCamera(*__va->__fbb,
																								 __va->__o->cameras[i].get(),
																								 __va->__rehasher);
																		 },
																		 &_va) :
						  0;
		auto _images = _o->images.size() ?
						 _fbb.CreateVector<flatbuffers::Offset<Image>>(_o->images.size(),
																	   [](size_t i, _VectorArgs* __va) {
																		   return CreateImage(*__va->__fbb,
																							  __va->__o->images[i].get(),
																							  __va->__rehasher);
																	   },
																	   &_va) :
						 0;
		auto _materials
		  = _o->materials.size() ?
			  _fbb.CreateVector<flatbuffers::Offset<Material>>(_o->materials.size(),
															   [](size_t i, _VectorArgs* __va) {
																   return CreateMaterial(*__va->__fbb,
																						 __va->__o->materials[i].get(),
																						 __va->__rehasher);
															   },
															   &_va) :
			  0;
		auto _meshes = _o->meshes.size() ?
						 _fbb.CreateVector<flatbuffers::Offset<Mesh>>(_o->meshes.size(),
																	  [](size_t i, _VectorArgs* __va) {
																		  return CreateMesh(*__va->__fbb,
																							__va->__o->meshes[i].get(),
																							__va->__rehasher);
																	  },
																	  &_va) :
						 0;
		auto _nodes = _o->nodes.size() ?
						_fbb.CreateVector<flatbuffers::Offset<Node>>(_o->nodes.size(),
																	 [](size_t i, _VectorArgs* __va) {
																		 return CreateNode(*__va->__fbb,
																						   __va->__o->nodes[i].get(),
																						   __va->__rehasher);
																	 },
																	 &_va) :
						0;
		auto _samplers
		  = _o->samplers.size() ?
			  _fbb.CreateVector<flatbuffers::Offset<Sampler>>(_o->samplers.size(),
															  [](size_t i, _VectorArgs* __va) {
																  return CreateSampler(*__va->__fbb,
																					   __va->__o->samplers[i].get(),
																					   __va->__rehasher);
															  },
															  &_va) :
			  0;
		auto _scene  = _o->scene;
		auto _scenes = _o->scenes.size() ?
						 _fbb.CreateVector<flatbuffers::Offset<Scene>>(_o->scenes.size(),
																	   [](size_t i, _VectorArgs* __va) {
																		   return CreateScene(*__va->__fbb,
																							  __va->__o->scenes[i].get(),
																							  __va->__rehasher);
																	   },
																	   &_va) :
						 0;
		auto _skins = _o->skins.size() ?
						_fbb.CreateVector<flatbuffers::Offset<Skin>>(_o->skins.size(),
																	 [](size_t i, _VectorArgs* __va) {
																		 return CreateSkin(*__va->__fbb,
																						   __va->__o->skins[i].get(),
																						   __va->__rehasher);
																	 },
																	 &_va) :
						0;
		auto _textures
		  = _o->textures.size() ?
			  _fbb.CreateVector<flatbuffers::Offset<Texture>>(_o->textures.size(),
															  [](size_t i, _VectorArgs* __va) {
																  return CreateTexture(*__va->__fbb,
																					   __va->__o->textures[i].get(),
																					   __va->__rehasher);
															  },
															  &_va) :
			  0;
		auto _extensions = _o->extensions.size() ? _fbb.CreateVector(_o->extensions) : 0;
		auto _extras	 = _o->extras.size() ? _fbb.CreateVector(_o->extras) : 0;
		return glTF_2_0::CreateRoot(_fbb,
									_extensionsUsed,
									_extensionsRequired,
									_accessors,
									_animations,
									_asset,
									_buffers,
									_bufferViews,
									_cameras,
									_images,
									_materials,
									_meshes,
									_nodes,
									_samplers,
									_scene,
									_scenes,
									_skins,
									_textures,
									_extensions,
									_extras);
	}

	inline const glTF_2_0::Root* GetRoot(const void* buf)
	{
		return flatbuffers::GetRoot<glTF_2_0::Root>(buf);
	}

	inline Root* GetMutableRoot(void* buf)
	{
		return flatbuffers::GetMutableRoot<Root>(buf);
	}

	inline const char* RootIdentifier()
	{
		return "glTF";
	}

	inline bool RootBufferHasIdentifier(const void* buf)
	{
		return flatbuffers::BufferHasIdentifier(buf, RootIdentifier());
	}

	inline bool VerifyRootBuffer(flatbuffers::Verifier& verifier)
	{
		return verifier.VerifyBuffer<glTF_2_0::Root>(RootIdentifier());
	}

	inline const char* RootExtension()
	{
		return "glf";
	}

	inline void FinishRootBuffer(flatbuffers::FlatBufferBuilder& fbb, flatbuffers::Offset<glTF_2_0::Root> root)
	{
		fbb.Finish(root, RootIdentifier());
	}

	inline std::unique_ptr<RootT> UnPackRoot(const void* buf, const flatbuffers::resolver_function_t* res = nullptr)
	{
		return std::unique_ptr<RootT>(GetRoot(buf)->UnPack(res));
	}

}	// namespace glTF_2_0

#endif	// FLATBUFFERS_GENERATED_GLTF_GLTF_2_0_H_
